<!DOCTYPE HTML>
<html lang="chs" class="sidebar-visible no-js ayu">

<head>
    <!-- Book generated using mdBook -->
    <meta charset="UTF-8">
    <title>Python 类 - 布武不舞</title>


    <!-- Custom HTML head -->
    
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#ffffff" />

    <link rel="icon" href="../../../favicon.svg">
    <link rel="shortcut icon" href="../../../favicon.png">
    <link rel="stylesheet" href="../../../css/variables.css">
    <link rel="stylesheet" href="../../../css/general.css">
    <link rel="stylesheet" href="../../../css/chrome.css">
    <link rel="stylesheet" href="../../../css/print.css" media="print">

    <!-- Fonts -->
    <link rel="stylesheet" href="../../../FontAwesome/css/font-awesome.css">
    <link rel="stylesheet" href="../../../fonts/fonts.css">

    <!-- Highlight.js Stylesheets -->
    <link rel="stylesheet" href="../../../highlight.css">
    <link rel="stylesheet" href="../../../tomorrow-night.css">
    <link rel="stylesheet" href="../../../ayu-highlight.css">

    <!-- Custom theme stylesheets -->
    <link rel="stylesheet" href="../../../theme/style3.css">


</head>

<body>

    <!-- Provide site root to javascript -->
    <script type="text/javascript">
        var path_to_root = "../../../";
        var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "ayu";
    </script>

    <!-- Work around some values being stored in localStorage wrapped in quotes -->
    <script type="text/javascript">
        try {
            var theme = localStorage.getItem('mdbook-theme');
            var sidebar = localStorage.getItem('mdbook-sidebar');
            if (theme.startsWith('"') && theme.endsWith('"')) {
                localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
            }
            if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
            }
        } catch (e) { }
    </script>

    <!-- Set the theme before any content is loaded, prevents flash -->
    <script type="text/javascript">
        var theme;
        try { theme = localStorage.getItem('mdbook-theme'); } catch (e) { }
        if (theme === null || theme === undefined) { theme = default_theme; }
        var html = document.querySelector('html');
        html.classList.remove('no-js')
        html.classList.remove('ayu')
        html.classList.add(theme);
        html.classList.add('js');
    </script>

    <!-- Hide / unhide sidebar before it is displayed -->
    <script type="text/javascript">
        var html = document.querySelector('html');
        var sidebar = 'hidden';
        if (document.body.clientWidth >= 1080) {
            try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch (e) { }
            sidebar = sidebar || 'visible';
        }
        html.classList.remove('sidebar-visible');
        html.classList.add("sidebar-" + sidebar);
    </script>

    <nav id="sidebar" class="sidebar" aria-label="Table of contents">
        <div class="sidebar-scrollbox">
            <ol class="chapter"><li class="chapter-item affix "><a href="../../../pre.html">目录</a></li><li class="chapter-item affix "><li class="part-title">Summary</li><li class="chapter-item "><a href="../../../markdown/markdown.html"><strong aria-hidden="true">1.</strong> Markdown&LaTeX</a></li><li class="chapter-item "><a href="../../../python/python.html"><strong aria-hidden="true">2.</strong> Python</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../python/win32com/pre.html"><strong aria-hidden="true">2.1.</strong> win32com</a></li><li class="chapter-item "><a href="../../../python/crawler/pre.html"><strong aria-hidden="true">2.2.</strong> crawler</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../python/crawler/BeautifulSoup.html"><strong aria-hidden="true">2.2.1.</strong> BeautifulSoup</a></li><li class="chapter-item "><a href="../../../python/crawler/re.html"><strong aria-hidden="true">2.2.2.</strong> re</a></li></ol></li><li class="chapter-item "><a href="../../../python/pytorch/pytorch.html"><strong aria-hidden="true">2.3.</strong> pytorch</a></li><li class="chapter-item "><a href="../../../python/np_pd/np_pd.html"><strong aria-hidden="true">2.4.</strong> others</a></li><li class="chapter-item "><a href="../../../python/python之禅/pre.html"><strong aria-hidden="true">2.5.</strong> python之禅</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../python/python之禅/optim.html"><strong aria-hidden="true">2.5.1.</strong> 结构上优化运行速度</a></li><li class="chapter-item "><a href="../../../python/python之禅/python_optim.html"><strong aria-hidden="true">2.5.2.</strong> 其他细节</a></li></ol></li></ol></li><li class="chapter-item "><a href="../../../cpp/pre.html"><strong aria-hidden="true">3.</strong> CPP</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><div><strong aria-hidden="true">3.1.</strong> cpp_primer_plus笔记</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../cpp/cpp_primer_plus/1.基础/index.html"><strong aria-hidden="true">3.1.1.</strong> 基础</a></li><li class="chapter-item "><a href="../../../cpp/cpp_primer_plus/2.函数/index.html"><strong aria-hidden="true">3.1.2.</strong> 函数</a></li><li class="chapter-item "><a href="../../../cpp/cpp_primer_plus/3.内存模型和名称空间/index.html"><strong aria-hidden="true">3.1.3.</strong> 内存模型和名称空间</a></li><li class="chapter-item "><a href="../../../cpp/cpp_primer_plus/4.对象和类/index.html"><strong aria-hidden="true">3.1.4.</strong> 对象和类</a></li><li class="chapter-item "><a href="../../../cpp/cpp_primer_plus/5.使用类/index.html"><strong aria-hidden="true">3.1.5.</strong> 使用类</a></li><li class="chapter-item "><a href="../../../cpp/cpp_primer_plus/6.类和动态内存分配/index.html"><strong aria-hidden="true">3.1.6.</strong> 类和动态内存分配</a></li><li class="chapter-item "><a href="../../../cpp/cpp_primer_plus/7.类继承/index.html"><strong aria-hidden="true">3.1.7.</strong> 类继承</a></li><li class="chapter-item "><a href="../../../cpp/cpp_primer_plus/8.C++中的代码重用/index.html"><strong aria-hidden="true">3.1.8.</strong> 代码重用</a></li><li class="chapter-item "><a href="../../../cpp/cpp_primer_plus/9.友元、异常和其他/index.html"><strong aria-hidden="true">3.1.9.</strong> 友元、异常及其他</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../../../rust/pre.html"><strong aria-hidden="true">4.</strong> Rust</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../rust/rust_holy/pre.html"><strong aria-hidden="true">4.1.</strong> Rust圣经👿摘要</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../rust/rust_holy/basic/pre.html"><strong aria-hidden="true">4.1.1.</strong> 基础知识</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../rust/rust_holy/basic/basic.html"><strong aria-hidden="true">4.1.1.1.</strong> 安装及其他</a></li><li class="chapter-item "><a href="../../../rust/rust_holy/basic/basic_types/pre.html"><strong aria-hidden="true">4.1.1.2.</strong> 基本类型</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../rust/rust_holy/basic/basic_types/basic_types.html"><strong aria-hidden="true">4.1.1.2.1.</strong> 数值类型</a></li><li class="chapter-item "><a href="../../../rust/rust_holy/basic/basic_types/char.html"><strong aria-hidden="true">4.1.1.2.2.</strong> 字符,布尔,单元类型</a></li><li class="chapter-item "><a href="../../../rust/rust_holy/basic/basic_types/statement.html"><strong aria-hidden="true">4.1.1.2.3.</strong> 语句和表达式</a></li><li class="chapter-item "><a href="../../../rust/rust_holy/basic/basic_types/function.html"><strong aria-hidden="true">4.1.1.2.4.</strong> 函数</a></li></ol></li><li class="chapter-item "><a href="../../../rust/rust_holy/basic/variable.html"><strong aria-hidden="true">4.1.1.3.</strong> 变量绑定与解构</a></li><li class="chapter-item "><a href="../../../rust/rust_holy/basic/ownership/pre.html"><strong aria-hidden="true">4.1.1.4.</strong> 所有权,引用与借用</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../rust/rust_holy/basic/ownership/ownership.html"><strong aria-hidden="true">4.1.1.4.1.</strong> 所有权</a></li><li class="chapter-item "><a href="../../../rust/rust_holy/basic/ownership/borrowing.html"><strong aria-hidden="true">4.1.1.4.2.</strong> 引用与借用</a></li></ol></li><li class="chapter-item "><a href="../../../rust/rust_holy/basic/compound_type/pre.html"><strong aria-hidden="true">4.1.1.5.</strong> 复合类型</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../rust/rust_holy/basic/compound_type/string_slice.html"><strong aria-hidden="true">4.1.1.5.1.</strong> 字符串与切片</a></li><li class="chapter-item "><a href="../../../rust/rust_holy/basic/compound_type/tuple.html"><strong aria-hidden="true">4.1.1.5.2.</strong> 元组</a></li><li class="chapter-item "><a href="../../../rust/rust_holy/basic/compound_type/struct.html"><strong aria-hidden="true">4.1.1.5.3.</strong> 结构体</a></li><li class="chapter-item "><a href="../../../rust/rust_holy/basic/compound_type/enum.html"><strong aria-hidden="true">4.1.1.5.4.</strong> 枚举</a></li><li class="chapter-item "><a href="../../../rust/rust_holy/basic/compound_type/array.html"><strong aria-hidden="true">4.1.1.5.5.</strong> 数组</a></li></ol></li><li class="chapter-item "><a href="../../../rust/rust_holy/basic/flow_control.html"><strong aria-hidden="true">4.1.1.6.</strong> 流式控制</a></li><li class="chapter-item "><a href="../../../rust/rust_holy/basic/match_pattern/pre.html"><strong aria-hidden="true">4.1.1.7.</strong> 模式匹配</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../rust/rust_holy/basic/match_pattern/if_let.html"><strong aria-hidden="true">4.1.1.7.1.</strong> if_let</a></li><li class="chapter-item "><a href="../../../rust/rust_holy/basic/match_pattern/option.html"><strong aria-hidden="true">4.1.1.7.2.</strong> option</a></li><li class="chapter-item "><a href="../../../rust/rust_holy/basic/match_pattern/pattern_match.html"><strong aria-hidden="true">4.1.1.7.3.</strong> 模式适用场景</a></li><li class="chapter-item "><a href="../../../rust/rust_holy/basic/match_pattern/all_patterns.html"><strong aria-hidden="true">4.1.1.7.4.</strong> 全模式列表</a></li></ol></li><li class="chapter-item "><a href="../../../rust/rust_holy/basic/method.html"><strong aria-hidden="true">4.1.1.8.</strong> 方法method</a></li><li class="chapter-item "><a href="../../../rust/rust_holy/basic/generics_and_traits/pre.html"><strong aria-hidden="true">4.1.1.9.</strong> 泛型和特征</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../rust/rust_holy/basic/generics_and_traits/generic.html"><strong aria-hidden="true">4.1.1.9.1.</strong> 泛型Generics</a></li><li class="chapter-item "><a href="../../../rust/rust_holy/basic/generics_and_traits/trait.html"><strong aria-hidden="true">4.1.1.9.2.</strong> 特征Traits</a></li><li class="chapter-item "><a href="../../../rust/rust_holy/basic/generics_and_traits/trait_object.html"><strong aria-hidden="true">4.1.1.9.3.</strong> 特征对象</a></li><li class="chapter-item "><a href="../../../rust/rust_holy/basic/generics_and_traits/advance_trait.html"><strong aria-hidden="true">4.1.1.9.4.</strong> 深入特征</a></li></ol></li><li class="chapter-item "><a href="../../../rust/rust_holy/basic/collections/pre.html"><strong aria-hidden="true">4.1.1.10.</strong> 集合</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../rust/rust_holy/basic/collections/vector.html"><strong aria-hidden="true">4.1.1.10.1.</strong> 动态数组</a></li><li class="chapter-item "><a href="../../../rust/rust_holy/basic/collections/hashmap.html"><strong aria-hidden="true">4.1.1.10.2.</strong> hashmap</a></li></ol></li><li class="chapter-item "><a href="../../../rust/rust_holy/basic/lifetime.html"><strong aria-hidden="true">4.1.1.11.</strong> 生命周期🆘</a></li><li class="chapter-item "><a href="../../../rust/rust_holy/basic/result_error/pre.html"><strong aria-hidden="true">4.1.1.12.</strong> 返回值与错误处理</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../rust/rust_holy/basic/result_error/panic.html"><strong aria-hidden="true">4.1.1.12.1.</strong> panic!深入</a></li><li class="chapter-item "><a href="../../../rust/rust_holy/basic/result_error/result.html"><strong aria-hidden="true">4.1.1.12.2.</strong> 返回值Result</a></li></ol></li><li class="chapter-item "><a href="../../../rust/rust_holy/basic/crate_module/pre.html"><strong aria-hidden="true">4.1.1.13.</strong> 包和模块</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../rust/rust_holy/basic/crate_module/crate.html"><strong aria-hidden="true">4.1.1.13.1.</strong> 包Crate</a></li><li class="chapter-item "><a href="../../../rust/rust_holy/basic/crate_module/module.html"><strong aria-hidden="true">4.1.1.13.2.</strong> 模块Module</a></li><li class="chapter-item "><a href="../../../rust/rust_holy/basic/crate_module/use.html"><strong aria-hidden="true">4.1.1.13.3.</strong> 使用use及受限可见性</a></li></ol></li><li class="chapter-item "><a href="../../../rust/rust_holy/basic/comment.html"><strong aria-hidden="true">4.1.1.14.</strong> 注释和文档</a></li><li class="chapter-item "><a href="../../../rust/rust_holy/basic/converse.html"><strong aria-hidden="true">4.1.1.15.</strong> 类型转换</a></li><li class="chapter-item "><a href="../../../rust/rust_holy/basic/formatted_output.html"><strong aria-hidden="true">4.1.1.16.</strong> 格式化输出</a></li></ol></li><li class="chapter-item "><a href="../../../rust/rust_holy/basic-practice/intro.html"><strong aria-hidden="true">4.1.2.</strong> 入门实战：构建一个简单命令行程序</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../rust/rust_holy/basic-practice/base-features.html"><strong aria-hidden="true">4.1.2.1.</strong> 基本功能</a></li><li class="chapter-item "><a href="../../../rust/rust_holy/basic-practice/refactoring.html"><strong aria-hidden="true">4.1.2.2.</strong> 增加模块化和错误处理</a></li><li class="chapter-item "><a href="../../../rust/rust_holy/basic-practice/tests.html"><strong aria-hidden="true">4.1.2.3.</strong> 测试驱动开发</a></li><li class="chapter-item "><a href="../../../rust/rust_holy/basic-practice/envs.html"><strong aria-hidden="true">4.1.2.4.</strong> 使用环境变量</a></li><li class="chapter-item "><a href="../../../rust/rust_holy/basic-practice/iterators.html"><strong aria-hidden="true">4.1.2.5.</strong> 使用迭代器来改进程序(可选)</a></li></ol></li><li class="chapter-item "><a href="../../../rust/rust_holy/advance/intro.html"><strong aria-hidden="true">4.1.3.</strong> Rust 高级进阶</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../rust/rust_holy/advance/lifetime/intro.html"><strong aria-hidden="true">4.1.3.1.</strong> 生命周期</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../rust/rust_holy/advance/lifetime/advance.html"><strong aria-hidden="true">4.1.3.1.1.</strong> 深入生命周期</a></li><li class="chapter-item "><a href="../../../rust/rust_holy/advance/lifetime/static.html"><strong aria-hidden="true">4.1.3.1.2.</strong> &'static 和 T: 'static</a></li></ol></li><li class="chapter-item "><a href="../../../rust/rust_holy/advance/functional-programing/intro.html"><strong aria-hidden="true">4.1.3.2.</strong> 函数式编程: 闭包、迭代器</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../rust/rust_holy/advance/functional-programing/closure.html"><strong aria-hidden="true">4.1.3.2.1.</strong> 闭包 Closure</a></li><li class="chapter-item "><a href="../../../rust/rust_holy/advance/functional-programing/iterator.html"><strong aria-hidden="true">4.1.3.2.2.</strong> 迭代器 Iterator</a></li></ol></li><li class="chapter-item "><a href="../../../rust/rust_holy/advance/into-types/intro.html"><strong aria-hidden="true">4.1.3.3.</strong> 深入类型</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../rust/rust_holy/advance/into-types/custom-type.html"><strong aria-hidden="true">4.1.3.3.1.</strong> newtype 和 类型别名</a></li><li class="chapter-item "><a href="../../../rust/rust_holy/advance/into-types/sized.html"><strong aria-hidden="true">4.1.3.3.2.</strong> Sized 和不定长类型 DST</a></li><li class="chapter-item "><a href="../../../rust/rust_holy/advance/into-types/enum-int.html"><strong aria-hidden="true">4.1.3.3.3.</strong> 枚举和整数</a></li></ol></li><li class="chapter-item "><a href="../../../rust/rust_holy/advance/smart-pointer/intro.html"><strong aria-hidden="true">4.1.3.4.</strong> 智能指针</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../rust/rust_holy/advance/smart-pointer/box.html"><strong aria-hidden="true">4.1.3.4.1.</strong> Box堆对象分配</a></li><li class="chapter-item "><a href="../../../rust/rust_holy/advance/smart-pointer/deref.html"><strong aria-hidden="true">4.1.3.4.2.</strong> Deref 解引用</a></li><li class="chapter-item "><a href="../../../rust/rust_holy/advance/smart-pointer/drop.html"><strong aria-hidden="true">4.1.3.4.3.</strong> Drop 释放资源</a></li><li class="chapter-item "><a href="../../../rust/rust_holy/advance/smart-pointer/rc-arc.html"><strong aria-hidden="true">4.1.3.4.4.</strong> Rc 与 Arc 实现 1vN 所有权机制</a></li><li class="chapter-item "><a href="../../../rust/rust_holy/advance/smart-pointer/cell-refcell.html"><strong aria-hidden="true">4.1.3.4.5.</strong> Cell 与 RefCell 内部可变性</a></li></ol></li><li class="chapter-item "><a href="../../../rust/rust_holy/advance/circle-self-ref/intro.html"><strong aria-hidden="true">4.1.3.5.</strong> 循环引用与自引用</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../rust/rust_holy/advance/circle-self-ref/circle-reference.html"><strong aria-hidden="true">4.1.3.5.1.</strong> Weak 与循环引用</a></li><li class="chapter-item "><a href="../../../rust/rust_holy/advance/circle-self-ref/self-referential.html"><strong aria-hidden="true">4.1.3.5.2.</strong> 结构体中的自引用</a></li></ol></li><li class="chapter-item "><a href="../../../rust/rust_holy/advance/concurrency-with-threads/intro.html"><strong aria-hidden="true">4.1.3.6.</strong> 多线程并发编程</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../rust/rust_holy/advance/concurrency-with-threads/concurrency-parallelism.html"><strong aria-hidden="true">4.1.3.6.1.</strong> 并发和并行</a></li><li class="chapter-item "><a href="../../../rust/rust_holy/advance/concurrency-with-threads/thread.html"><strong aria-hidden="true">4.1.3.6.2.</strong> 使用多线程</a></li><li class="chapter-item "><a href="../../../rust/rust_holy/advance/concurrency-with-threads/message-passing.html"><strong aria-hidden="true">4.1.3.6.3.</strong> 线程同步：消息传递</a></li><li class="chapter-item "><a href="../../../rust/rust_holy/advance/concurrency-with-threads/sync1.html"><strong aria-hidden="true">4.1.3.6.4.</strong> 线程同步：锁、Condvar 和信号量</a></li><li class="chapter-item "><a href="../../../rust/rust_holy/advance/concurrency-with-threads/sync2.html"><strong aria-hidden="true">4.1.3.6.5.</strong> 线程同步：Atomic 原子操作与内存顺序</a></li><li class="chapter-item "><a href="../../../rust/rust_holy/advance/concurrency-with-threads/send-sync.html"><strong aria-hidden="true">4.1.3.6.6.</strong> 基于 Send 和 Sync 的线程安全</a></li><li class="chapter-item "><a href="../../../rust/rust_holy/advance/concurrency-with-threads/web-server.html"><strong aria-hidden="true">4.1.3.6.7.</strong> 实践应用：多线程 Web 服务器 todo</a></li></ol></li><li class="chapter-item "><a href="../../../rust/rust_holy/advance/global-variable.html"><strong aria-hidden="true">4.1.3.7.</strong> 全局变量</a></li><li class="chapter-item "><a href="../../../rust/rust_holy/advance/errors.html"><strong aria-hidden="true">4.1.3.8.</strong> 错误处理</a></li><li class="chapter-item "><a href="../../../rust/rust_holy/advance/unsafe/intro.html"><strong aria-hidden="true">4.1.3.9.</strong> Unsafe Rust</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../rust/rust_holy/advance/unsafe/superpowers.html"><strong aria-hidden="true">4.1.3.9.1.</strong> 五种兵器</a></li><li class="chapter-item "><a href="../../../rust/rust_holy/advance/unsafe/inline-asm.html"><strong aria-hidden="true">4.1.3.9.2.</strong> 内联汇编 todo</a></li></ol></li><li class="chapter-item "><a href="../../../rust/rust_holy/advance/macro.html"><strong aria-hidden="true">4.1.3.10.</strong> Macro 宏编程</a></li></ol></li><li class="chapter-item "><a href="../../../rust/rust_holy/async-rust/intro.html"><strong aria-hidden="true">4.1.4.</strong> Rust 异步编程</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../rust/rust_holy/async-rust/async/intro.html"><strong aria-hidden="true">4.1.4.1.</strong> async/await 异步编程</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../rust/rust_holy/async-rust/async/getting-started.html"><strong aria-hidden="true">4.1.4.1.1.</strong> async 编程入门</a></li><li class="chapter-item "><a href="../../../rust/rust_holy/async-rust/async/future-excuting.html"><strong aria-hidden="true">4.1.4.1.2.</strong> 底层探秘: Future 执行与任务调度</a></li><li class="chapter-item "><a href="../../../rust/rust_holy/async-rust/async/pin-unpin.html"><strong aria-hidden="true">4.1.4.1.3.</strong> 定海神针 Pin 和 Unpin</a></li><li class="chapter-item "><a href="../../../rust/rust_holy/async-rust/async/async-await.html"><strong aria-hidden="true">4.1.4.1.4.</strong> async/await 和 Stream 流处理</a></li><li class="chapter-item "><a href="../../../rust/rust_holy/async-rust/async/multi-futures-simultaneous.html"><strong aria-hidden="true">4.1.4.1.5.</strong> 同时运行多个 Future</a></li><li class="chapter-item "><a href="../../../rust/rust_holy/async-rust/async/pain-points-and-workarounds.html"><strong aria-hidden="true">4.1.4.1.6.</strong> 一些疑难问题的解决办法</a></li><li class="chapter-item "><a href="../../../rust/rust_holy/async-rust/async/web-server.html"><strong aria-hidden="true">4.1.4.1.7.</strong> 实践应用：Async Web 服务器</a></li></ol></li><li class="chapter-item "><a href="../../../rust/rust_holy/async-rust/tokio/intro.html"><strong aria-hidden="true">4.1.4.2.</strong> Tokio 使用指南</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../rust/rust_holy/async-rust/tokio/overview.html"><strong aria-hidden="true">4.1.4.2.1.</strong> tokio 概览</a></li><li class="chapter-item "><a href="../../../rust/rust_holy/async-rust/tokio/getting-startted.html"><strong aria-hidden="true">4.1.4.2.2.</strong> 使用初印象</a></li><li class="chapter-item "><a href="../../../rust/rust_holy/async-rust/tokio/spawning.html"><strong aria-hidden="true">4.1.4.2.3.</strong> 创建异步任务</a></li><li class="chapter-item "><a href="../../../rust/rust_holy/async-rust/tokio/shared-state.html"><strong aria-hidden="true">4.1.4.2.4.</strong> 共享状态</a></li><li class="chapter-item "><a href="../../../rust/rust_holy/async-rust/tokio/channels.html"><strong aria-hidden="true">4.1.4.2.5.</strong> 消息传递</a></li><li class="chapter-item "><a href="../../../rust/rust_holy/async-rust/tokio/io.html"><strong aria-hidden="true">4.1.4.2.6.</strong> I/O</a></li><li class="chapter-item "><a href="../../../rust/rust_holy/async-rust/tokio/frame.html"><strong aria-hidden="true">4.1.4.2.7.</strong> 解析数据帧</a></li><li class="chapter-item "><a href="../../../rust/rust_holy/async-rust/tokio/async.html"><strong aria-hidden="true">4.1.4.2.8.</strong> 深入 async</a></li><li class="chapter-item "><a href="../../../rust/rust_holy/async-rust/tokio/select.html"><strong aria-hidden="true">4.1.4.2.9.</strong> select</a></li><li class="chapter-item "><a href="../../../rust/rust_holy/async-rust/tokio/stream.html"><strong aria-hidden="true">4.1.4.2.10.</strong> 类似迭代器的 Stream</a></li><li class="chapter-item "><a href="../../../rust/rust_holy/async-rust/tokio/graceful-shutdown.html"><strong aria-hidden="true">4.1.4.2.11.</strong> 优雅的关闭</a></li><li class="chapter-item "><a href="../../../rust/rust_holy/async-rust/tokio/bridging-with-sync.html"><strong aria-hidden="true">4.1.4.2.12.</strong> 异步跟同步共存</a></li></ol></li></ol></li><li class="chapter-item "><a href="../../../rust/rust_holy/cargo/intro.html"><strong aria-hidden="true">4.1.5.</strong> Cargo 使用指南</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../rust/rust_holy/cargo/getting-started.html"><strong aria-hidden="true">4.1.5.1.</strong> 上手使用</a></li><li class="chapter-item "><a href="../../../rust/rust_holy/cargo/guide/intro.html"><strong aria-hidden="true">4.1.5.2.</strong> 基础指南</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../rust/rust_holy/cargo/guide/why-exist.html"><strong aria-hidden="true">4.1.5.2.1.</strong> 为何会有 Cargo</a></li><li class="chapter-item "><a href="../../../rust/rust_holy/cargo/guide/download-package.html"><strong aria-hidden="true">4.1.5.2.2.</strong> 下载并构建 Package</a></li><li class="chapter-item "><a href="../../../rust/rust_holy/cargo/guide/dependencies.html"><strong aria-hidden="true">4.1.5.2.3.</strong> 添加依赖</a></li><li class="chapter-item "><a href="../../../rust/rust_holy/cargo/guide/package-layout.html"><strong aria-hidden="true">4.1.5.2.4.</strong> Package 目录结构</a></li><li class="chapter-item "><a href="../../../rust/rust_holy/cargo/guide/cargo-toml-lock.html"><strong aria-hidden="true">4.1.5.2.5.</strong> Cargo.toml vs Cargo.lock</a></li><li class="chapter-item "><a href="../../../rust/rust_holy/cargo/guide/tests-ci.html"><strong aria-hidden="true">4.1.5.2.6.</strong> 测试和 CI</a></li><li class="chapter-item "><a href="../../../rust/rust_holy/cargo/guide/cargo-cache.html"><strong aria-hidden="true">4.1.5.2.7.</strong> Cargo 缓存</a></li><li class="chapter-item "><a href="../../../rust/rust_holy/cargo/guide/build-cache.html"><strong aria-hidden="true">4.1.5.2.8.</strong> Build 缓存</a></li></ol></li><li class="chapter-item "><a href="../../../rust/rust_holy/cargo/reference/intro.html"><strong aria-hidden="true">4.1.5.3.</strong> 进阶指南</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../rust/rust_holy/cargo/reference/specify-deps.html"><strong aria-hidden="true">4.1.5.3.1.</strong> 指定依赖项</a></li><li class="chapter-item "><a href="../../../rust/rust_holy/cargo/reference/deps-overriding.html"><strong aria-hidden="true">4.1.5.3.2.</strong> 依赖覆盖</a></li><li class="chapter-item "><a href="../../../rust/rust_holy/cargo/reference/manifest.html"><strong aria-hidden="true">4.1.5.3.3.</strong> Cargo.toml 清单详解</a></li><li class="chapter-item "><a href="../../../rust/rust_holy/cargo/reference/cargo-target.html"><strong aria-hidden="true">4.1.5.3.4.</strong> Cargo Target</a></li><li class="chapter-item "><a href="../../../rust/rust_holy/cargo/reference/workspaces.html"><strong aria-hidden="true">4.1.5.3.5.</strong> 工作空间 Workspace</a></li><li class="chapter-item "><a href="../../../rust/rust_holy/cargo/reference/features/intro.html"><strong aria-hidden="true">4.1.5.3.6.</strong> 条件编译 Features</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../rust/rust_holy/cargo/reference/features/examples.html"><strong aria-hidden="true">4.1.5.3.6.1.</strong> Features 示例</a></li></ol></li><li class="chapter-item "><a href="../../../rust/rust_holy/cargo/reference/profiles.html"><strong aria-hidden="true">4.1.5.3.7.</strong> 发布配置 Profile</a></li><li class="chapter-item "><a href="../../../rust/rust_holy/cargo/reference/configuration.html"><strong aria-hidden="true">4.1.5.3.8.</strong> 通过 config.toml 对 Cargo 进行配置</a></li><li class="chapter-item "><a href="../../../rust/rust_holy/cargo/reference/publishing-on-crates.io.html"><strong aria-hidden="true">4.1.5.3.9.</strong> 发布到 crates.io</a></li><li class="chapter-item "><a href="../../../rust/rust_holy/cargo/reference/build-script/intro.html"><strong aria-hidden="true">4.1.5.3.10.</strong> 构建脚本 build.rs</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../rust/rust_holy/cargo/reference/build-script/examples.html"><strong aria-hidden="true">4.1.5.3.10.1.</strong> 构建脚本示例</a></li></ol></li></ol></li></ol></li><li class="chapter-item "><a href="../../../rust/rust_holy/logs/intro.html"><strong aria-hidden="true">4.1.6.</strong> 日志和监控</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../rust/rust_holy/logs/about-log.html"><strong aria-hidden="true">4.1.6.1.</strong> 日志详解</a></li><li class="chapter-item "><a href="../../../rust/rust_holy/logs/log.html"><strong aria-hidden="true">4.1.6.2.</strong> 日志门面 log</a></li><li class="chapter-item "><a href="../../../rust/rust_holy/logs/tracing.html"><strong aria-hidden="true">4.1.6.3.</strong> 使用 tracing 记录日志</a></li><li class="chapter-item "><a href="../../../rust/rust_holy/logs/tracing-logger.html"><strong aria-hidden="true">4.1.6.4.</strong> 自定义 tracing 的输出格式</a></li><li class="chapter-item "><a href="../../../rust/rust_holy/logs/observe/intro.html"><strong aria-hidden="true">4.1.6.5.</strong> 监控</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../rust/rust_holy/logs/observe/about-observe.html"><strong aria-hidden="true">4.1.6.5.1.</strong> 可观测性</a></li><li class="chapter-item "><a href="../../../rust/rust_holy/logs/observe/trace.html"><strong aria-hidden="true">4.1.6.5.2.</strong> 分布式追踪</a></li></ol></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">4.1.7.</strong> Appendix</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../rust/rust_holy/appendix/keywords.html"><strong aria-hidden="true">4.1.7.1.</strong> 关键字</a></li><li class="chapter-item "><a href="../../../rust/rust_holy/appendix/operators.html"><strong aria-hidden="true">4.1.7.2.</strong> 运算符与符号</a></li><li class="chapter-item "><a href="../../../rust/rust_holy/appendix/expressions.html"><strong aria-hidden="true">4.1.7.3.</strong> 表达式</a></li><li class="chapter-item "><a href="../../../rust/rust_holy/appendix/derive.html"><strong aria-hidden="true">4.1.7.4.</strong> 派生特征 trait</a></li><li class="chapter-item "><a href="../../../rust/rust_holy/appendix/prelude.html"><strong aria-hidden="true">4.1.7.5.</strong> prelude 模块 todo</a></li><li class="chapter-item "><a href="../../../rust/rust_holy/appendix/rust-version.html"><strong aria-hidden="true">4.1.7.6.</strong> Rust 版本说明</a></li><li class="chapter-item "><a href="../../../rust/rust_holy/appendix/rust-versions/intro.html"><strong aria-hidden="true">4.1.7.7.</strong> Rust 历次版本更新解读</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../appendix/rust-versions/1.58.html"><strong aria-hidden="true">4.1.7.7.1.</strong> 1.58</a></li><li class="chapter-item "><a href="../../../appendix/rust-versions/1.59.html"><strong aria-hidden="true">4.1.7.7.2.</strong> 1.59</a></li><li class="chapter-item "><a href="../../../appendix/rust-versions/1.60.html"><strong aria-hidden="true">4.1.7.7.3.</strong> 1.60</a></li><li class="chapter-item "><a href="../../../appendix/rust-versions/1.61.html"><strong aria-hidden="true">4.1.7.7.4.</strong> 1.61</a></li><li class="chapter-item "><a href="../../../appendix/rust-versions/1.62.html"><strong aria-hidden="true">4.1.7.7.5.</strong> 1.62</a></li><li class="chapter-item "><a href="../../../appendix/rust-versions/1.63.html"><strong aria-hidden="true">4.1.7.7.6.</strong> 1.63</a></li><li class="chapter-item "><a href="../../../appendix/rust-versions/1.64.html"><strong aria-hidden="true">4.1.7.7.7.</strong> 1.64</a></li><li class="chapter-item "><a href="../../../appendix/rust-versions/1.65.html"><strong aria-hidden="true">4.1.7.7.8.</strong> 1.65</a></li><li class="chapter-item "><a href="../../../appendix/rust-versions/1.66.html"><strong aria-hidden="true">4.1.7.7.9.</strong> 1.66</a></li><li class="chapter-item "><a href="../../../appendix/rust-versions/1.67.html"><strong aria-hidden="true">4.1.7.7.10.</strong> 1.67</a></li></ol></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../../../rust/pyo3/pyo3.html"><strong aria-hidden="true">4.2.</strong> PyO3</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../rust/pyo3/pythonmodules.html"><strong aria-hidden="true">4.2.1.</strong> Python 模组</a></li><li class="chapter-item "><a href="../../../rust/pyo3/pythonfunctions/pre.html"><strong aria-hidden="true">4.2.2.</strong> Python 函数</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../rust/pyo3/pythonfunctions/function_signatures.html"><strong aria-hidden="true">4.2.2.1.</strong> 函数签名 Function signatures</a></li><li class="chapter-item "><a href="../../../rust/pyo3/pythonfunctions/error_handling.html"><strong aria-hidden="true">4.2.2.2.</strong> 错误处理 Error handling</a></li></ol></li><li class="chapter-item expanded "><a href="../../../rust/pyo3/python_classes/pre.html" class="active"><strong aria-hidden="true">4.2.3.</strong> Python 类</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../rust/pyo3/python_classes/class_customization.html"><strong aria-hidden="true">4.2.3.1.</strong> 类的自定义</a></li><li class="chapter-item "><a href="../../../rust/pyo3/python_classes/basic_type.html"><strong aria-hidden="true">4.2.3.2.</strong> 基本对象的自定义</a></li><li class="chapter-item "><a href="../../../rust/pyo3/python_classes/emulate_number_type.html"><strong aria-hidden="true">4.2.3.3.</strong> 模拟数值类型</a></li><li class="chapter-item "><a href="../../../rust/pyo3/python_classes/emulate_callable_objects.html"><strong aria-hidden="true">4.2.3.4.</strong> 模拟可调用类型</a></li></ol></li><li class="chapter-item "><a href="../../../rust/pyo3/type_conversion/pre.html"><strong aria-hidden="true">4.2.4.</strong> 类型转换</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../rust/pyo3/type_conversion/tables.html"><strong aria-hidden="true">4.2.4.1.</strong> 将Rust类型映射为python类型</a></li><li class="chapter-item "><a href="../../../rust/pyo3/type_conversion/traits.html"><strong aria-hidden="true">4.2.4.2.</strong> 转换特征 Conversion traits</a></li></ol></li><li class="chapter-item "><a href="../../../rust/pyo3/python_exceptions.html"><strong aria-hidden="true">4.2.5.</strong> Python异常</a></li><li class="chapter-item "><a href="../../../rust/pyo3/python_from_rust.html"><strong aria-hidden="true">4.2.6.</strong> 在Rust中调用Python</a></li><li class="chapter-item "><a href="../../../rust/pyo3/GIL.html"><strong aria-hidden="true">4.2.7.</strong> GIL, 可变性与对象类型</a></li><li class="chapter-item "><a href="../../../rust/pyo3/parallelism.html"><strong aria-hidden="true">4.2.8.</strong> 并行</a></li><li class="chapter-item "><a href="../../../rust/pyo3/debugging.html"><strong aria-hidden="true">4.2.9.</strong> debug</a></li><li class="chapter-item "><a href="../../../rust/pyo3/features_reference.html"><strong aria-hidden="true">4.2.10.</strong> 特性引用Features reference</a></li><li class="chapter-item "><a href="../../../rust/pyo3/memory_management.html"><strong aria-hidden="true">4.2.11.</strong> 内存管理</a></li><li class="chapter-item "><a href="../../../rust/pyo3/advanced_topic.html"><strong aria-hidden="true">4.2.12.</strong> 高阶话题</a></li><li class="chapter-item "><a href="../../../rust/pyo3/building_distribution.md/pre.html"><strong aria-hidden="true">4.2.13.</strong> 构建与发布</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../rust/pyo3/building_distribution.md/multiple_version.html"><strong aria-hidden="true">4.2.13.1.</strong> 支持多个Python版本</a></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">4.2.14.</strong> 有用的包</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../rust/pyo3/useful_crates/logging.html"><strong aria-hidden="true">4.2.14.1.</strong> Logging</a></li><li class="chapter-item "><a href="../../../rust/pyo3/useful_crates/async_and_await.html"><strong aria-hidden="true">4.2.14.2.</strong> async与await</a></li></ol></li></ol></li></ol></li><li class="chapter-item "><a href="../../../others/pre.html"><strong aria-hidden="true">5.</strong> Others</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../others/com.html"><strong aria-hidden="true">5.1.</strong> COM组件</a></li><li class="chapter-item "><a href="../../../others/cython/pre.html"><strong aria-hidden="true">5.2.</strong> cython</a></li></ol></li><li class="chapter-item "><a href="../../../ml/ml.html"><strong aria-hidden="true">6.</strong> ML</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../ml/pre/pre.html"><strong aria-hidden="true">6.1.</strong> 绪言</a></li><li class="chapter-item "><a href="../../../ml/chapter2/chapter2.html"><strong aria-hidden="true">6.2.</strong> 模型的评估与选择</a></li><li class="chapter-item "><a href="../../../ml/chapter3/chapter3.html"><strong aria-hidden="true">6.3.</strong> 线性模型</a></li><li class="chapter-item "><a href="../../../ml/chapter4/chapter4.html"><strong aria-hidden="true">6.4.</strong> 决策树</a></li><li class="chapter-item "><a href="../../../ml/chapter5/chapter5.html"><strong aria-hidden="true">6.5.</strong> 神经网络</a></li><li class="chapter-item "><a href="../../../ml/chapter6/chapter6.html"><strong aria-hidden="true">6.6.</strong> 支持向量机</a></li><li class="chapter-item "><a href="../../../ml/chapter7/chapter7.html"><strong aria-hidden="true">6.7.</strong> 贝叶斯分类器</a></li><li class="chapter-item "><a href="../../../ml/chapter8/chapter8.html"><strong aria-hidden="true">6.8.</strong> EM算法</a></li><li class="chapter-item "><a href="../../../ml/chapter9/chapter9.html"><strong aria-hidden="true">6.9.</strong> 集成学习</a></li><li class="chapter-item "><a href="../../../ml/chapter10/chapter10.html"><strong aria-hidden="true">6.10.</strong> 聚类算法</a></li><li class="chapter-item "><a href="../../../ml/chapter11/chapter11.html"><strong aria-hidden="true">6.11.</strong> 降维与度量学习</a></li><li class="chapter-item "><a href="../../../ml/chapter12/chapter12.html"><strong aria-hidden="true">6.12.</strong> 特征选择与稀疏学习</a></li><li class="chapter-item "><a href="../../../ml/chapter13/chapter13.html"><strong aria-hidden="true">6.13.</strong> 计算学习理论</a></li><li class="chapter-item "><a href="../../../ml/chapter14/chapter14.html"><strong aria-hidden="true">6.14.</strong> 半监督学习</a></li><li class="chapter-item "><a href="../../../ml/chapter15/chapter15.html"><strong aria-hidden="true">6.15.</strong> 概率图模型</a></li><li class="chapter-item "><a href="../../../ml/chapter16/chapter16.html"><strong aria-hidden="true">6.16.</strong> 强化学习</a></li></ol></li><li class="chapter-item "><a href="../../../nn/basic.html"><strong aria-hidden="true">7.</strong> NN</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../nn/feedforward.html"><strong aria-hidden="true">7.1.</strong> 前馈神经网络</a></li><li class="chapter-item "><a href="../../../nn/memory.html"><strong aria-hidden="true">7.2.</strong> 循环神经网络</a></li><li class="chapter-item "><a href="../../../nn/GAN.html"><strong aria-hidden="true">7.3.</strong> 生成对抗网络</a></li><li class="chapter-item "><a href="../../../nn/graph.html"><strong aria-hidden="true">7.4.</strong> 图神经网络</a></li></ol></li><li class="chapter-item "><a href="../../../DRL/DRL.html"><strong aria-hidden="true">8.</strong> DRL</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../DRL/RL.html"><strong aria-hidden="true">8.1.</strong> RL</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../DRL/RL/chapter1/chapter1.html"><strong aria-hidden="true">8.1.1.</strong> 有模型数值迭代</a></li><li class="chapter-item "><a href="../../../DRL/RL/chapter2/chapter2.html"><strong aria-hidden="true">8.1.2.</strong> 回合更新价值迭代</a></li><li class="chapter-item "><a href="../../../DRL/RL/chapter3/chapter3.html"><strong aria-hidden="true">8.1.3.</strong> 时序差分价值迭代</a></li><li class="chapter-item "><a href="../../../DRL/RL/chapter4/chapter4.html"><strong aria-hidden="true">8.1.4.</strong> 函数近似方法</a></li><li class="chapter-item "><a href="../../../DRL/RL/chapter5/chapter5.html"><strong aria-hidden="true">8.1.5.</strong> 回合更新策略梯度方法</a></li><li class="chapter-item "><a href="../../../DRL/RL/chapter6/chapter6.html"><strong aria-hidden="true">8.1.6.</strong> 执行者/评论者方法</a></li><li class="chapter-item "><a href="../../../DRL/RL/chapter7/chapter7.html"><strong aria-hidden="true">8.1.7.</strong> 连续动作空间的确定性策略</a></li></ol></li><li class="chapter-item "><a href="../../../DRL/fin.html"><strong aria-hidden="true">8.2.</strong> FIN</a></li><li class="chapter-item "><a href="../../../DRL/DRL.html"><strong aria-hidden="true">8.3.</strong> DRL</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../DRL/DRL/chatgpt.html"><strong aria-hidden="true">8.3.1.</strong> ChatGPT历史</a></li></ol></li></ol></li><li class="chapter-item "><a href="../../../option/option.html"><strong aria-hidden="true">9.</strong> Option</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../option/basic/pre.html"><strong aria-hidden="true">9.1.</strong> 期权基础概念</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../option/basic/basic.html"><strong aria-hidden="true">9.1.1.</strong> 基础知识</a></li><li class="chapter-item "><a href="../../../option/basic/spread.html"><strong aria-hidden="true">9.1.2.</strong> 价差</a></li><li class="chapter-item "><a href="../../../option/basic/theorems.html"><strong aria-hidden="true">9.1.3.</strong> 深入希腊值</a></li><li class="chapter-item "><a href="../../../option/basic/trading.html"><strong aria-hidden="true">9.1.4.</strong> 日内交易要点</a></li></ol></li><li class="chapter-item "><a href="../../../option/models/pre.html"><strong aria-hidden="true">9.2.</strong> 期权模型</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../option/models/sv.html"><strong aria-hidden="true">9.2.1.</strong> 经典SV</a></li><li class="chapter-item "><a href="../../../option/models/rough.html"><strong aria-hidden="true">9.2.2.</strong> RV</a></li><li class="chapter-item "><a href="../../../option/models/wing_model.html"><strong aria-hidden="true">9.2.3.</strong> wing_model</a></li></ol></li><li class="chapter-item "><a href="../../../option/automatic_trading/automatic_trading_pre.html"><strong aria-hidden="true">9.3.</strong> Automatic_Trading</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../option/automatic_trading/automatic_hedging/automatic_hedging_pre.html"><strong aria-hidden="true">9.3.1.</strong> Automatic_Hedging</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../option/automatic_trading/automatic_hedging/hedging_vanilla.html"><strong aria-hidden="true">9.3.1.1.</strong> hedging_vanilla</a></li></ol></li></ol></li></ol></li><li class="chapter-item "><a href="../../../philosophy/philosophy.html"><strong aria-hidden="true">10.</strong> Phylosophy</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../philosophy/history/history.html"><strong aria-hidden="true">10.1.</strong> 西方哲学史</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../philosophy/history/chapter1.html"><strong aria-hidden="true">10.1.1.</strong> 古希腊哲学</a></li><li class="chapter-item "><a href="../../../philosophy/history/chapter2.html"><strong aria-hidden="true">10.1.2.</strong> 希腊化时期和中世纪的哲学</a></li><li class="chapter-item "><a href="../../../philosophy/history/chapter3.html"><strong aria-hidden="true">10.1.3.</strong> 近代早期的哲学</a></li><li class="chapter-item "><a href="../../../philosophy/history/chapter4.html"><strong aria-hidden="true">10.1.4.</strong> 近代晚期和19世纪哲学</a></li><li class="chapter-item "><a href="../../../philosophy/history/chapter5.html"><strong aria-hidden="true">10.1.5.</strong> 20世纪和当代哲学</a></li></ol></li></ol></li></ol>
        </div>
        <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
    </nav>

    <div id="page-wrapper" class="page-wrapper">

        <div class="page">
                        <div id="menu-bar-hover-placeholder"></div>
            <div id="menu-bar" class="menu-bar sticky bordered">
                <div class="left-buttons">
                    <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents"
                        aria-label="Toggle Table of Contents" aria-controls="sidebar">
                        <i class="fa fa-bars"></i>
                    </button>
                    <button id="theme-toggle" class="icon-button" type="button" title="Change theme"
                        aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                        <i class="fa fa-paint-brush"></i>
                    </button>
                    <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                        <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                        <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                        <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                        <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                        <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu (default)</button>
                        </li>
                    </ul>
                    <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)"
                        aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S"
                        aria-controls="searchbar">
                        <i class="fa fa-search"></i>
                    </button>
                </div>

                <h1 class="menu-title">布武不舞</h1>

                <div class="right-buttons">
                    <a href="../../../print.html" title="Print this book" aria-label="Print this book">
                        <i id="print-button" class="fa fa-print"></i>
                    </a>

                </div>
            </div>

            <div id="search-wrapper" class="hidden">
                <form id="searchbar-outer" class="searchbar-outer">
                    <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..."
                        aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                </form>
                <div id="searchresults-outer" class="searchresults-outer hidden">
                    <div id="searchresults-header" class="searchresults-header"></div>
                    <ul id="searchresults">
                    </ul>
                </div>
            </div>

            <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
            <script type="text/javascript">
                document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');

                // Get viewed page store
                var viewed_key = 'mdbook-viewed';
                var viewed_map = {};
                try {
                    var viewed_storage = localStorage.getItem(viewed_key);
                    if (viewed_storage) {
                        viewed_map = JSON.parse(viewed_storage)
                    }
                } catch (e) { }

                Array.from(document.querySelectorAll('#sidebar a')).forEach(function (link) {
                    link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);

                    // Apply viewed style
                    if (viewed_map[link.pathname]) {
                        link.classList.add('md-viewed')
                    }
                });

                // Mark viewed after 30s
                setTimeout(function () {
                    viewed_map[location.pathname] = 1;
                    localStorage.setItem(viewed_key, JSON.stringify(viewed_map));
                }, 30000)
            </script>

            <div id="content" class="content">
                <!-- Page table of contents -->
                <div class="sidetoc">
                    <nav class="pagetoc"></nav>
                </div>
                <main>
                    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="python-classes"><a class="header" href="#python-classes">Python classes</a></h1>
<p>PyO3 提供许多 Rust 宏支持的属性来定义 Rust 结构的 Python 类。</p>
<p>主要的属性是 <code>#[pyclass]</code>，放在一个 Rust 结构或者一个 fieldless 的枚举上面来为其生成一个 Python 类型。通常它们会有一个 <code>#[pymethods]</code>：用 <code>impl</code> 块注释的结构，用来定义 Python 方法和生成的 Python 类型的约束。（如果开启了 <code>multiple-pymethods</code>）特性，那么每个 <code>#[pyclass]</code>可以有多个 <code>#[pymethods]</code> 块。<code>#[pymethods]</code> 可以有类似 <code>__str__</code> 的 Python 魔术方法的实现。</p>
<h2 id="定义一个新类"><a class="header" href="#定义一个新类">定义一个新类</a></h2>
<p>定义一个 Python 类，需要在 Rust 结构或者 fieldless 枚举前加上 <code>#[pyclass]</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use pyo3::prelude::*;

#[pyclass]
struct Integer {
    inner: i32,
}

// A &quot;tuple&quot; struct
#[pyclass]
struct Number(i32);

// PyO3 supports custom discriminants in enums
#[pyclass]
enum HttpResponse {
    Ok = 200,
    NotFound = 404,
    Teapot = 418,
    // ...
}

#[pyclass]
enum MyEnum {
    Variant,
    OtherVariant = 30, // PyO3 supports custom discriminants.
}
<span class="boring">}</span></code></pre></pre>
<h3 id="限制"><a class="header" href="#限制">限制</a></h3>
<p>为了整合 Rust 类型与 Python，PyO3 需要对可以用 <code>#[pyclass]</code> 注释的类型加以限制。特别地，它们<strong>不能有生命周期</strong>的参数，<strong>不能有泛型</strong>参数，<strong>必须实现了 <a href="https://doc.rust-lang.org/std/marker/trait.Send.html"><code>send</code></a></strong>。理由如下</p>
<h4 id="没有生命周期"><a class="header" href="#没有生命周期">没有生命周期</a></h4>
<p>Rust 编译器为了内存安全使用生命周期，它们只在编译中使用，无法传输到 Python 这样的动态语言中。</p>
<h4 id="没有泛型参数"><a class="header" href="#没有泛型参数">没有泛型参数</a></h4>
<p>一个带有泛型参数 <code>T</code> 的 Rust 结构 <code>Foo&lt;T&gt;</code> ，每次传入一个不同的具体类型的<code>T</code>时，会生成新的编译实现。这在 Python 中并不现实，因为 Python 中编译器只需要 <code>Foo</code> 的一个单独的实现。</p>
<h4 id="必须要有send"><a class="header" href="#必须要有send">必须要有<a href="https://doc.rust-lang.org/std/marker/trait.Send.html"><code>Send</code></a></a></h4>
<p>因为 Python 解释器中，Python 对象在线程中是免费共享的，不能保证哪个线程会最终丢弃这个对象。因此，每个用 <code>#[pyclass]</code> 注释的类型必须实现 <a href="https://doc.rust-lang.org/std/marker/trait.Send.html"><code>Send</code></a>（除非注释 <code>#[pyclass(unsendable)]</code>）。</p>
<h2 id="构造器constructor"><a class="header" href="#构造器constructor">构造器（Constructor）</a></h2>
<p>默认下是不可能通过 Python 代码创建一个自定义类的实例啊。为了声明一个构造器，需要定义一个方法并用 <code>#[new]</code> 属性注释它。只有 Python 的<code>__new__</code> 方法可以，而<code>__init__</code>不可用。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[pymethods]
impl Number {
    #[new]
    fn new(value: i32) -&gt; Self {
        Number(value)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>可选，如果你的 <code>#[new]</code> 可能会失败你可以返回 <code>PyResult&lt;Self&gt;</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[pymethods]
impl Nonzero {
    #[new]
    fn py_new(value: i32) -&gt; PyResult&lt;Self&gt; {
        if value == 0 {
            Err(PyValueError::new_err(&quot;cannot be zero&quot;))
        } else {
            Ok(Nonzero(value))
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>如果没有声明含有 <code>#[new]</code> 的方法，那么只能由 Rust 创建实例，Python 无法创建。</p>
<h2 id="将类添加到模组上"><a class="header" href="#将类添加到模组上">将类添加到模组上</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[pymodule]
fn my_module(_py: Python&lt;'_&gt;, m: &amp;PyModule) -&gt; PyResult&lt;()&gt; {
    m.add_class::&lt;Number&gt;()?;
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="pycell-and-interior-mutability"><a class="header" href="#pycell-and-interior-mutability">PyCell and interior mutability</a></h2>
<p>有时候需要将 <code>pyclass</code> 转换成一个 Python 对象然后在 Rust 代码中使用它，<code>PyCell</code>是主要的接口。</p>
<p><code>PyCell&lt;T: PyClass&gt;</code>永远出现在 Python 语块中，所以 Rust 没有它的所有权。也就是说，Rust只能提取<code>&amp;PyCell&lt;T&gt;</code>, not a 而不是<code>PyCell&lt;T&gt;</code>。</p>
<p>因此，想要安全地改变<code>&amp;PyCell</code>后的数据，PyO3 采用例如 <code>RefCell</code> 这样的 Interior Mutability Pattern。</p>
<p>回忆Rust中借用的规则</p>
<ul>
<li>在任意时刻，只能同时存在一个可变引用或者数个不可变引用</li>
<li>引用必须永远是有效的</li>
</ul>
<p><code>PyCell</code>，类似<code>RefCell</code>，通过在运行中跟踪引用来确保这些借用规则</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[pyclass]
struct MyClass {
    #[pyo3(get)]
    num: i32,
}
Python::with_gil(|py| {
    let obj = PyCell::new(py, MyClass { num: 3 }).unwrap();
    {
        let obj_ref = obj.borrow(); // Get PyRef
        assert_eq!(obj_ref.num, 3);
        // You cannot get PyRefMut unless all PyRefs are dropped
        assert!(obj.try_borrow_mut().is_err());
    }
    {
        let mut obj_mut = obj.borrow_mut(); // Get PyRefMut
        obj_mut.num = 5;
        // You cannot get any other refs until the PyRefMut is dropped
        assert!(obj.try_borrow().is_err());
        assert!(obj.try_borrow_mut().is_err());
    }

    // You can convert `&amp;PyCell` to a Python object
    pyo3::py_run!(py, obj, &quot;assert obj.num == 5&quot;);
});
<span class="boring">}</span></code></pre></pre>
<p><code>&amp;PyCell&lt;T&gt;</code>被限制了与 <code>GILGuard</code> 同样的生命周期。为了使对象存活更长（例如，在Rust中将它存在一个结构中），可以使用<code>Py&lt;T&gt;</code>，它可以将一个对象存储得比 GIL 更久，然后需要 <code>Python&lt;'_&gt;</code>来获取。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[pyclass]
struct MyClass {
    num: i32,
}

fn return_myclass() -&gt; Py&lt;MyClass&gt; {
    Python::with_gil(|py| Py::new(py, MyClass { num: 1 }).unwrap())
}

let obj = return_myclass();

Python::with_gil(|py| {
    let cell = obj.as_ref(py); // Py&lt;MyClass&gt;::as_ref returns &amp;PyCell&lt;MyClass&gt;
    let obj_ref = cell.borrow(); // Get PyRef&lt;T&gt;
    assert_eq!(obj_ref.num, 1);
});
<span class="boring">}</span></code></pre></pre>
<h2 id="自定义类"><a class="header" href="#自定义类">自定义类</a></h2>
<p><code>#[pyclass]</code>可以使用如下参数</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">参数</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>crate = &quot;some::path&quot;</code></td><td style="text-align: left">导入<code>pyo3</code>包的路径，如果<code>::pyo3</code>不可用</td></tr>
<tr><td style="text-align: left"><code>dict</code></td><td style="text-align: left">给予这个类的实例一个空的<code>__dict__</code>来存储自定义属性</td></tr>
<tr><td style="text-align: left"><code>extends = BaseType</code></td><td style="text-align: left">使用一个自定义的基类，默认为<code>PyAny</code></td></tr>
<tr><td style="text-align: left"><code>freelist = N</code></td><td style="text-align: left">实现一个大小为 N 的 <a href="https://en.wikipedia.org/wiki/Free_list">free list</a>，对那些经常要创建和删除的类型可以提升性能</td></tr>
<tr><td style="text-align: left"><code>frozen</code></td><td style="text-align: left">声明你的类是不可变的。会移除当检索到Rust结构的共享引用时的顶层借用检查，但同时无法再获取到一个可变的引用。</td></tr>
<tr><td style="text-align: left"><code>get_all</code></td><td style="text-align: left">为类的所有域生成 getter</td></tr>
<tr><td style="text-align: left"><code>mapping</code></td><td style="text-align: left">告诉PyO3这个类是一个 <code>mapping</code>，</td></tr>
<tr><td style="text-align: left"><code>module = &quot;module_name&quot;</code></td><td style="text-align: left">Python中看到的类定义所在的模组名，默认为<code>builtins</code></td></tr>
<tr><td style="text-align: left"><code>name = &quot;python_name&quot;</code></td><td style="text-align: left">Python看到的类名</td></tr>
<tr><td style="text-align: left"><code>sequence</code></td><td style="text-align: left">告诉PyO3这个类是一个 <code>Sequence</code></td></tr>
<tr><td style="text-align: left"><code>set_all</code></td><td style="text-align: left">为这类的所有域生成 setter</td></tr>
<tr><td style="text-align: left"><code>subclass</code></td><td style="text-align: left">允许其他Python类或者<code>#[pyclass]</code>从这个类中继承，枚举无法被继承</td></tr>
<tr><td style="text-align: left"><code>text_signature = &quot;(arg1, arg2, ...)&quot;</code></td><td style="text-align: left">为Python类的 <code>__new__</code> 方法设置文字签名</td></tr>
<tr><td style="text-align: left"><code>unsendable</code></td><td style="text-align: left">如果你的结构不是 <a href="https://doc.rust-lang.org/std/marker/trait.Send.html"><code>Send</code></a>的，如果使用了 <code>unsendable</code>，你的类会 panic 如果被另一个线程调用</td></tr>
<tr><td style="text-align: left"><code>weakref</code></td><td style="text-align: left">允许这个类为<a href="https://docs.python.org/3/library/weakref.html">弱应用</a></td></tr>
</tbody></table>
</div>
<p>所有这些参数可以直接通过<code>#[pyclass(...)]</code>注释传递，或者通过<code>#[pyo3(...)]</code>传递，e.g.:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Argument supplied directly to the `#[pyclass]` annotation.
#[pyclass(name = &quot;SomeName&quot;, subclass)]
struct MyClass {}

// Argument supplied as a separate annotation.
#[pyclass]
#[pyo3(name = &quot;SomeName&quot;, subclass)]
struct MyClass {}
<span class="boring">}</span></code></pre></pre>
<h3 id="返回类型"><a class="header" href="#返回类型">返回类型</a></h3>
<p>一般来说，<code>#[new]</code>方法必须返回<code>T: Into&lt;PyClassInitializer&lt;Self&gt;&gt;</code>或者<code>PyResult&lt;T&gt;</code>，其中<code>T: Into&lt;PyClassInitializer&lt;Self&gt;&gt;</code>。</p>
<p>对于可能失败的构造器，同样可以把返回类型包装进一个<code>PyResult</code>。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left"></th><th style="text-align: left">不可能失败</th><th style="text-align: left">可能失败</th></tr></thead><tbody>
<tr><td style="text-align: left">非继承</td><td style="text-align: left"><code>T</code></td><td style="text-align: left"><code>PyResult&lt;T&gt;</code></td></tr>
<tr><td style="text-align: left">继承(T继承U)</td><td style="text-align: left"><code>(T, U)</code></td><td style="text-align: left"><code>PyResult&lt;(T, U)&gt;</code></td></tr>
<tr><td style="text-align: left">继承(一般情形)</td><td style="text-align: left"><a href="https://pyo3.rs/main/doc/pyo3/pyclass_init/struct.pyclassinitializer"><code>PyClassInitializer&lt;T&gt;</code></a></td><td style="text-align: left"><code>PyResult&lt;PyClassInitializer&lt;T&gt;&gt;</code></td></tr>
</tbody></table>
</div>
<h2 id="继承-inheritance"><a class="header" href="#继承-inheritance">继承 Inheritance</a></h2>
<p>默认情况下，<code>object</code> i.e. <code>PyAny</code> 被用作基本类。要覆盖这种默认，对<code>pyclass</code>使用 <code>extends</code> 参数，参数值为基类的完整路径。</p>
<p>方便起见，<code>(T, U)</code> 实现了<code>Into&lt;PyClassInitializer&lt;T&gt;&gt;</code>，其中<code>U</code>是<code>T</code>的基类。但是对更深的嵌套循环，还是必须明确地使用<code>PyClassInitializer&lt;T&gt;</code>。</p>
<p>要从一个子类获得其父类，对方法使用<code>PyRef</code>（而不是<code>&amp;self</code>）或者<code>PyRefMut</code>（而不是<code>&amp;mut self</code>）。这样就可以通过<code>&amp;Self::BaseClass</code>的<code>self_.as_ref()</code>或者<code>PyRef&lt;Self::BaseClass&gt;</code>的<code>self_.into_super()</code>获取父类。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use pyo3::prelude::*;

#[pyclass(subclass)]
struct BaseClass {
    val1: usize,
}

#[pymethods]
impl BaseClass {
    #[new]
    fn new() -&gt; Self {
        BaseClass { val1: 10 }
    }

    pub fn method(&amp;self) -&gt; PyResult&lt;usize&gt; {
        Ok(self.val1)
    }
}

#[pyclass(extends=BaseClass, subclass)]
struct SubClass {
    val2: usize,
}

#[pymethods]
impl SubClass {
    #[new]
    fn new() -&gt; (Self, BaseClass) {
        (SubClass { val2: 15 }, BaseClass::new())
    }

    fn method2(self_: PyRef&lt;'_, Self&gt;) -&gt; PyResult&lt;usize&gt; {
        let super_ = self_.as_ref(); // Get &amp;BaseClass
        super_.method().map(|x| x * self_.val2)
    }
}

#[pyclass(extends=SubClass)]
struct SubSubClass {
    val3: usize,
}

#[pymethods]
impl SubSubClass {
    #[new]
    fn new() -&gt; PyClassInitializer&lt;Self&gt; {
        PyClassInitializer::from(SubClass::new()).add_subclass(SubSubClass { val3: 20 })
    }

    fn method3(self_: PyRef&lt;'_, Self&gt;) -&gt; PyResult&lt;usize&gt; {
        let v = self_.val3;
        let super_ = self_.into_super(); // Get PyRef&lt;'_, SubClass&gt;
        SubClass::method2(super_).map(|x| x * v)
    }
}
Python::with_gil(|py| {
    let subsub = pyo3::PyCell::new(py, SubSubClass::new()).unwrap();
    pyo3::py_run!(py, subsub, &quot;assert subsub.method3() == 3000&quot;)
});
<span class="boring">}</span></code></pre></pre>
<p>也可以继承类似<code>PyDict</code>的原生类型，只要它们实现了<code>PySizedLayout</code>。但是由于技术问题，现在还未向继承了原生类型的类型提供安全的 upcasting 方法。即使在这样的情况下，可以 <em>unsafely get a base class by raw pointer conversion</em></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(not(Py_LIMITED_API))] {
use pyo3::prelude::*;
use pyo3::types::PyDict;
use pyo3::AsPyPointer;
use std::collections::HashMap;

#[pyclass(extends=PyDict)]
#[derive(Default)]
struct DictWithCounter {
    counter: HashMap&lt;String, usize&gt;,
}

#[pymethods]
impl DictWithCounter {
    #[new]
    fn new() -&gt; Self {
        Self::default()
    }

    fn set(mut self_: PyRefMut&lt;'_, Self&gt;, key: String, value: &amp;PyAny) -&gt; PyResult&lt;()&gt; {
        self_.counter.entry(key.clone()).or_insert(0);
        let py = self_.py();
        let dict: &amp;PyDict = unsafe { py.from_borrowed_ptr_or_err(self_.as_ptr())? };
        dict.set_item(key, value)
    }
}
Python::with_gil(|py| {
    let cnt = pyo3::PyCell::new(py, DictWithCounter::new()).unwrap();
    pyo3::py_run!(py, cnt, &quot;cnt.set('abc', 10); assert cnt['abc'] == 10&quot;)
});
}
<span class="boring">}</span></code></pre></pre>
<p>如果 <code>SubClass</code> 没有提供基类的继承，编译会失败。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span>
#[pyclass]
struct BaseClass {
    val1: usize,
}

#[pyclass(extends=BaseClass)]
struct SubClass {
    val2: usize,
}

#[pymethods]
impl SubClass {
    #[new]
    fn new() -&gt; Self {
        SubClass { val2: 15 }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>当创建了一个Python实例时，原生基类的<code>__new__</code>构造器会隐式地被调用。确保在（希望基类获得的）<code>#[new]</code>方法中接受参数，即使它们没有在那个<code>fn</code>中被使用：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[allow(dead_code)]
#[cfg(not(Py_LIMITED_API))] {
<span class="boring">use pyo3::prelude::*;
</span>use pyo3::types::PyDict;

#[pyclass(extends=PyDict)]
struct MyDict {
    private: i32,
}

#[pymethods]
impl MyDict {
    #[new]
    #[pyo3(signature = (*args, **kwargs))]
    fn new(args: &amp;PyAny, kwargs: Option&lt;&amp;PyAny&gt;) -&gt; Self {
        Self { private: 0 }
    }

    // some custom methods that use `private` here...
}
Python::with_gil(|py| {
    let cls = py.get_type::&lt;MyDict&gt;();
    pyo3::py_run!(py, cls, &quot;cls(a=1, b=2)&quot;)
});
}
<span class="boring">}</span></code></pre></pre>
<p>这里，<code>args</code>和<code>kwargs</code>允许创建传递了初始 item 的实例，例如<code>MyDict(item_sequence)</code> 或 <code>MyDict(a=1, b=2)</code>。</p>
<h2 id="对象性质"><a class="header" href="#对象性质">对象性质</a></h2>
<p>PyO3 支持两种方式来对<code>#[pyclass]</code>添加性质：</p>
<ul>
<li>对简单的结构域，没有副作用，可以直接在<code>#[pyclass]</code>的域定义中添加<code>#[pyo3(get, set)]</code>属性</li>
<li>对于需要计算（computation）的属性，可以在<a href="#instance-methods"><code>#[pymethods]</code></a>块中定义<code>#[getter]</code> 和 <code>#[setter]</code> 函数</li>
</ul>
<h3 id="使用pyo3get-set的对象性质"><a class="header" href="#使用pyo3get-set的对象性质">使用<code>#[pyo3(get, set)]</code>的对象性质</a></h3>
<p>对于成员变量只是读取和填写（be read and written）的简单情形，可以用<code>pyo3</code>属性在<code>#[pyclass]</code>域中声明 getters 和 setters，下面是例子：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span>#[pyclass]
struct MyClass {
    #[pyo3(get, set)]
    num: i32,
}
<span class="boring">}</span></code></pre></pre>
<p>上述代码使得 <code>num</code> 域可以作为一个<code>self.num</code> Python性质来读取和覆写。要将这个性质在另一个域可见，和其他选项（options）一起指明这个标注，e.g. <code>#[pyo3(get, set, name = &quot;custom_name&quot;)]</code>。</p>
<p>通过单独使用 <code>#[pyo3(get)]</code> 或 <code>#[pyo3(set)]</code>可以使性质变为只读或者只写。</p>
<p>要使用这些标注，域类型必须实现一些转换特征：</p>
<ul>
<li>对 <code>get</code>，域类型必须实现 <code>IntoPy&lt;PyObject&gt;</code> 和 <code>Clone</code></li>
<li>对 <code>set</code> ，域类型必须实现<code>FromPyObject</code></li>
</ul>
<h3 id="使用getter和setter的对象属性"><a class="header" href="#使用getter和setter的对象属性">使用<code>#[getter]</code>和<code>#[setter]</code>的对象属性</a></h3>
<p>对于没有满足 <code>#[pyo3(get, set)]</code> 特征需求，或者需要副作用的情形，可以在一个<code>#[pymethods]</code> <code>impl</code>块中定义描述符方法（descriptor method）</p>
<p>通过使用 <code>#[getter]</code> 和 <code>#[setter]</code> 属性，下面是一个例子</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use pyo3::prelude::*;
#[pyclass]
struct MyClass {
    num: i32,
}

#[pymethods]
impl MyClass {
    #[getter]
    fn num(&amp;self) -&gt; PyResult&lt;i32&gt; {
        Ok(self.num)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>一个 getter 或 setter 的函数名默认用作属性名。有几种方法覆写这个名字。</p>
<p>如果 getter 和 setter 函数名分别以 <code>get_</code> 和 <code>set_</code> 开头，描述符的名字会变成这个前缀去掉后的名字。这对于像 <code>type</code> 的 Rust 关键字也有用（<a href="https://doc.rust-lang.org/edition-guide/rust-2018/module-system/raw-identifiers.html">raw identifiers</a>）。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use pyo3::prelude::*;
#[pyclass]
struct MyClass {
    num: i32,
}
#[pymethods]
impl MyClass {
    #[getter]
    fn get_num(&amp;self) -&gt; PyResult&lt;i32&gt; {
        Ok(self.num)
    }

    #[setter]
    fn set_num(&amp;mut self, value: i32) -&gt; PyResult&lt;()&gt; {
        self.num = value;
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<p>这里，定义了性质 <code>num</code>，可以在 Python 中用 <code>self.num</code> 获取它。</p>
<p><code>#[getter]</code> 和 <code>#[setter]</code> 都接收一个参数。如果参数被指定了，它将被用作性质的名字，i.e.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use pyo3::prelude::*;
#[pyclass]
struct MyClass {
   num: i32,
}
#[pymethods]
impl MyClass {
    #[getter(number)]
    fn num(&amp;self) -&gt; PyResult&lt;i32&gt; {
        Ok(self.num)
    }

    #[setter(number)]
    fn set_num(&amp;mut self, value: i32) -&gt; PyResult&lt;()&gt; {
        self.num = value;
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<p>这里，定义了性质 <code>number</code> 并且在 Python 中可以用 <code>self.number</code> 获取它。</p>
<p>通过 <code>#[setter]</code> 或 <code>#[pyo3(set)]</code> 定义的属性永远会对 <code>del</code> 算子抛出 <code>AttributeError</code>，要自定义 <code>del</code> 参见<a href="https://github.com/PyO3/pyo3/issues/1778">#1778</a>.</p>
<h2 id="实例方法"><a class="header" href="#实例方法">实例方法</a></h2>
<p>要定义一个 Python 相容的方法，必须用 <code>#[pymethods]</code> 方法标注结构的 <code>impl</code> 块。PyO3 为所有在这个块里的函数生成与 Python 相容的包装器，像描述符，类方法，静态方法等等。</p>
<p>既然 Rust 允许任意数量的 <code>impl</code> 块，可以任意切分方法。但是要对同一结构同时标注多个 <code>#[pymethods]</code> 的 <code>impl</code> 块，必须使用PyO3的 <code>multiple-pymethods</code> 特性。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use pyo3::prelude::*;
#[pyclass]
struct MyClass {
    num: i32,
}
#[pymethods]
impl MyClass {
    fn method1(&amp;self) -&gt; PyResult&lt;i32&gt; {
        Ok(10)
    }

    fn set_method(&amp;mut self, value: i32) -&gt; PyResult&lt;()&gt; {
        self.num = value;
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<p>对这些方法的调用受 GIL保护，所以 <code>&amp;self</code> 和 <code>&amp;mut self</code> 都可以使用。返回类型必须为 <code>PyResult&lt;T&gt;</code> 或者某个实现了 <code>IntoPy&lt;PyObject&gt;</code> 的 <code>T</code>，后者在方法不会抛出Python异常时是允许的。</p>
<p>一个 <code>Python</code> 参数可以作为方法签名的一部分被指定，此时 <code>py</code> 变量被方法包装器注入，e.g.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use pyo3::prelude::*;
#[pyclass]
struct MyClass {
#[allow(dead_code)]
    num: i32,
}
#[pymethods]
impl MyClass {
    fn method2(&amp;self, py: Python&lt;'_&gt;) -&gt; PyResult&lt;i32&gt; {
        Ok(10)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>从 Python 看来，这个例子中的 <code>method2</code> 不接受任何变量。</p>
<h2 id="类方法"><a class="header" href="#类方法">类方法</a></h2>
<p>为一个自定义类创建一个类方法，需要对方法标注 <code>#[classmethod]</code> 属性。这和Python中的<code>@classmethod</code>是等价的。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use pyo3::prelude::*;
use pyo3::types::PyType;
#[pyclass]
struct MyClass {
    #[allow(dead_code)]
    num: i32,
}
#[pymethods]
impl MyClass {
    #[classmethod]
    fn cls_method(cls: &amp;PyType) -&gt; PyResult&lt;i32&gt; {
        Ok(10)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>声明一个可被Python调用的类方法</p>
<ul>
<li>第一个参数是方法被调用的类的类型对象</li>
<li>第一个参数隐式的是 <code>&amp;PyType</code> 类型</li>
<li>对于 <code>parameter-list</code> 的细节，参见 <code>Method arguments</code> 章节</li>
<li>返回类型必须为 <code>PyResult&lt;T&gt;</code> 或者某个实现了 <code>IntoPy&lt;PyObject&gt;</code> 的类型 <code>T</code></li>
</ul>
<h2 id="静态方法"><a class="header" href="#静态方法">静态方法</a></h2>
<p>要为自定义类创建一个静态方法，需要用 <code>#[staticmethod]</code> 属性标注该方法，返回类型必须为<code>PyResult&lt;T&gt;</code> 或者某个实现了 <code>IntoPy&lt;PyObject&gt;</code> 的类型 <code>T</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use pyo3::prelude::*;
#[pyclass]
struct MyClass {
    #[allow(dead_code)]
    num: i32,
}
#[pymethods]
impl MyClass {
    #[staticmethod]
    fn static_method(param1: i32, param2: &amp;str) -&gt; PyResult&lt;i32&gt; {
        Ok(10)
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="类属性"><a class="header" href="#类属性">类属性</a></h2>
<p>要创建一个类属性，也称为（<code>class variable</code>, <code>classattr</code>），可以用 <code>#[classattr]</code> 标注一个没有任何变量的方法。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use pyo3::prelude::*;
#[pyclass]
struct MyClass {}
#[pymethods]
impl MyClass {
    #[classattr]
    fn my_attribute() -&gt; String {
        &quot;hello&quot;.to_string()
    }
}

Python::with_gil(|py| {
    let my_class = py.get_type::&lt;MyClass&gt;();
    pyo3::py_run!(py, my_class, &quot;assert my_class.my_attribute == 'hello'&quot;)
});
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>Note: 如果方法有一个 <code>Result</code> 返回类型并且返回了 <code>Err</code>，PyO3会在类创建过程中 panic</p>
</blockquote>
<p>如果只用了 <code>const</code> 来定义类属性，也可以标注对应的常量：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use pyo3::prelude::*;
#[pyclass]
struct MyClass {}
#[pymethods]
impl MyClass {
    #[classattr]
    const MY_CONST_ATTRIBUTE: &amp;'static str = &quot;foobar&quot;;
}
<span class="boring">}</span></code></pre></pre>
<h2 id="方法变量"><a class="header" href="#方法变量">方法变量</a></h2>
<p>类似<code>#[pyfunction]</code>，可以用 <code>#[pyo3(signature = (...))]</code> 属性来指定 <code>#[pymethods]</code> 接收变量的方式，参见方法签名章节。</p>
<p>下述例子定义了一个具有<code>method</code>方法的类 <code>MyClass</code>。这个方法有一个签名，它为 <code>num</code> 和 <code>name</code> 设置了默认值，并且表明 <code>py_args</code> 会接收所有的位置变量，而 <code>py_kwargs</code> 会接收所有的关键字变量：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use pyo3::prelude::*;
use pyo3::types::{PyDict, PyTuple};

#[pyclass]
struct MyClass {
    num: i32,
}
#[pymethods]
impl MyClass {
    #[new]
    #[pyo3(signature = (num=-1))]
    fn new(num: i32) -&gt; Self {
        MyClass { num }
    }

    #[pyo3(signature = (num=10, *py_args, name=&quot;Hello&quot;, **py_kwargs))]
    fn method(
        &amp;mut self,
        num: i32,
        py_args: &amp;PyTuple,
        name: &amp;str,
        py_kwargs: Option&lt;&amp;PyDict&gt;,
    ) -&gt; String {
        let num_before = self.num;
        self.num = num;
        format!(
            &quot;num={} (was previously={}), py_args={:?}, name={}, py_kwargs={:?} &quot;,
            num, num_before, py_args, name, py_kwargs,
        )
    }
}
<span class="boring">}</span></code></pre></pre>
<p>而在Python中是这样子的</p>
<pre><code class="language-python">&gt;&gt;&gt; import mymodule
&gt;&gt;&gt; mc = mymodule.MyClass()
&gt;&gt;&gt; print(mc.method(44, False, &quot;World&quot;, 666, x=44, y=55))
py_args=('World', 666), py_kwargs=Some({'x': 44, 'y': 55}), name=Hello, num=44, num_before=-1
&gt;&gt;&gt; print(mc.method(num=-1, name=&quot;World&quot;))
py_args=(), py_kwargs=None, name=World, num=-1, num_before=44
</code></pre>
<h2 id="使得类方法签名对python可用"><a class="header" href="#使得类方法签名对python可用">使得类方法签名对Python可用</a></h2>
<p><code>#[pyfunction]</code> 的 <code>text_signature = &quot;...&quot;</code> 选项对类和方法也是可用的：</p>
<pre><pre class="playground"><code class="language-rust">#![allow(dead_code)]
use pyo3::prelude::*;
use pyo3::types::PyType;

// it works even if the item is not documented:
#[pyclass(text_signature = &quot;(c, d, /)&quot;)]
struct MyClass {}

#[pymethods]
impl MyClass {
    // the signature for the constructor is attached
    // to the struct definition instead.
    #[new]
    fn new(c: i32, d: &amp;str) -&gt; Self {
        Self {}
    }
    // the self argument should be written $self
    #[pyo3(text_signature = &quot;($self, e, f)&quot;)]
    fn my_method(&amp;self, e: i32, f: i32) -&gt; i32 {
        e + f
    }
    #[classmethod]
    #[pyo3(text_signature = &quot;(cls, e, f)&quot;)]
    fn my_class_method(cls: &amp;PyType, e: i32, f: i32) -&gt; i32 {
        e + f
    }
    #[staticmethod]
    #[pyo3(text_signature = &quot;(e, f)&quot;)]
    fn my_static_method(e: i32, f: i32) -&gt; i32 {
        e + f
    }
}

fn main() -&gt; PyResult&lt;()&gt; {
    Python::with_gil(|py| {
        let inspect = PyModule::import(py, &quot;inspect&quot;)?.getattr(&quot;signature&quot;)?;
        let module = PyModule::new(py, &quot;my_module&quot;)?;
        module.add_class::&lt;MyClass&gt;()?;
        let class = module.getattr(&quot;MyClass&quot;)?;

        if cfg!(not(Py_LIMITED_API)) || py.version_info() &gt;= (3, 10)  {
            let doc: String = class.getattr(&quot;__doc__&quot;)?.extract()?;
            assert_eq!(doc, &quot;&quot;);

            let sig: String = inspect
                .call1((class,))?
                .call_method0(&quot;__str__&quot;)?
                .extract()?;
            assert_eq!(sig, &quot;(c, d, /)&quot;);
       } else {
            let doc: String = class.getattr(&quot;__doc__&quot;)?.extract()?;
            assert_eq!(doc, &quot;&quot;);

            inspect.call1((class,)).expect_err(&quot;`text_signature` on classes is not compatible with compilation in `abi3` mode until Python 3.10 or greater&quot;);
         }

        {
            let method = class.getattr(&quot;my_method&quot;)?;

            assert!(method.getattr(&quot;__doc__&quot;)?.is_none());

            let sig: String = inspect
                .call1((method,))?
                .call_method0(&quot;__str__&quot;)?
                .extract()?;
            assert_eq!(sig, &quot;(self, /, e, f)&quot;);
        }

        {
            let method = class.getattr(&quot;my_class_method&quot;)?;

            assert!(method.getattr(&quot;__doc__&quot;)?.is_none());

            let sig: String = inspect
                .call1((method,))?
                .call_method0(&quot;__str__&quot;)?
                .extract()?;
            assert_eq!(sig, &quot;(cls, e, f)&quot;);
        }

        {
            let method = class.getattr(&quot;my_static_method&quot;)?;

            assert!(method.getattr(&quot;__doc__&quot;)?.is_none());

            let sig: String = inspect
                .call1((method,))?
                .call_method0(&quot;__str__&quot;)?
                .extract()?;
            assert_eq!(sig, &quot;(e, f)&quot;);
        }

        Ok(())
    })
}</code></pre></pre>
<p>注意到在<code>abi3</code>模式下编译时，类的 <code>text_signature</code> 只在 Python 3.10 或更高的版本相容。</p>
<h2 id="pyclass枚举"><a class="header" href="#pyclass枚举">#[pyclass]枚举</a></h2>
<p>目前PyO3只支持 fieldless 枚举。PyO3对每个变量添加了类属性，所以你不用定义 <code>#[new]</code> 就可以在Python中获取它们。PyO3同样提供了 <code>__richcmp__</code> 和 <code>__int__</code> 的默认实现，所以它们可以用 <code>==</code> 来进行比较：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use pyo3::prelude::*;
#[pyclass]
enum MyEnum {
    Variant,
    OtherVariant,
}

Python::with_gil(|py| {
    let x = Py::new(py, MyEnum::Variant).unwrap();
    let y = Py::new(py, MyEnum::OtherVariant).unwrap();
    let cls = py.get_type::&lt;MyEnum&gt;();
    pyo3::py_run!(py, x y cls, r#&quot;
        assert x == cls.Variant
        assert y == cls.OtherVariant
        assert x != y
    &quot;#)
})
<span class="boring">}</span></code></pre></pre>
<p>也可以将枚举转换为 <code>int</code>：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use pyo3::prelude::*;
#[pyclass]
enum MyEnum {
    Variant,
    OtherVariant = 10,
}

Python::with_gil(|py| {
    let cls = py.get_type::&lt;MyEnum&gt;();
    let x = MyEnum::Variant as i32; // The exact value is assigned by the compiler.
    pyo3::py_run!(py, cls x, r#&quot;
        assert int(cls.Variant) == x
        assert int(cls.OtherVariant) == 10
        assert cls.OtherVariant == 10  # You can also compare against int.
        assert 10 == cls.OtherVariant
    &quot;#)
})
<span class="boring">}</span></code></pre></pre>
<p>PyO3 也为枚举提供了 <code>__repr__</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use pyo3::prelude::*;
#[pyclass]
enum MyEnum{
    Variant,
    OtherVariant,
}

Python::with_gil(|py| {
    let cls = py.get_type::&lt;MyEnum&gt;();
    let x = Py::new(py, MyEnum::Variant).unwrap();
    pyo3::py_run!(py, cls x, r#&quot;
        assert repr(x) == 'MyEnum.Variant'
        assert repr(cls.OtherVariant) == 'MyEnum.OtherVariant'
    &quot;#)
})
<span class="boring">}</span></code></pre></pre>
<p>PyO3定义的所有方法可以被覆写，例如想要覆写 <code>__repr__</code>：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use pyo3::prelude::*;
#[pyclass]
enum MyEnum {
    Answer = 42,
}

#[pymethods]
impl MyEnum {
    fn __repr__(&amp;self) -&gt; &amp;'static str {
        &quot;42&quot;
    }
}

Python::with_gil(|py| {
    let cls = py.get_type::&lt;MyEnum&gt;();
    pyo3::py_run!(py, cls, &quot;assert repr(cls.Answer) == '42'&quot;)
})
<span class="boring">}</span></code></pre></pre>
<p>枚举以及其变量也能使用 <code>#[pyo3(name)]</code> 来重命名：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use pyo3::prelude::*;
#[pyclass(name = &quot;RenamedEnum&quot;)]
enum MyEnum {
    #[pyo3(name = &quot;UPPERCASE&quot;)]
    Variant,
}

Python::with_gil(|py| {
    let x = Py::new(py, MyEnum::Variant).unwrap();
    let cls = py.get_type::&lt;MyEnum&gt;();
    pyo3::py_run!(py, x cls, r#&quot;
        assert repr(x) == 'RenamedEnum.UPPERCASE'
        assert x == cls.UPPERCASE
    &quot;#)
})
<span class="boring">}</span></code></pre></pre>
<p>不能使用枚举作为基类或者从其他类进行继承：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use pyo3::prelude::*;
#[pyclass(subclass)]
enum BadBase {
    Var1,
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use pyo3::prelude::*;

#[pyclass(subclass)]
struct Base;

#[pyclass(extends=Base)]
enum BadSubclass {
    Var1,
}
<span class="boring">}</span></code></pre></pre>
<p>在Python中，<code>#[pyclass]</code> 枚举目前还不能与<code>IntEnum</code> 一起用。</p>
<h2 id="实现的细节"><a class="header" href="#实现的细节">实现的细节</a></h2>
<p><code>#[pyclass]</code>宏依赖许多 conditional code generation，每个 <code>#[pyclass]</code> 可以选择性地拥有一个 <code>#[pymethods]</code> 块。</p>
<blockquote>
<p>To support this flexibility the <code>#[pyclass]</code> macro expands to a blob of boilerplate code which sets up the structure for <a href="https://github.com/dtolnay/case-studies/blob/master/autoref-specialization/README.md">&quot;dtolnay specialization&quot;</a>. This implementation pattern enables the Rust compiler to use <code>#[pymethods]</code> implementations when they are present, and fall back to default (empty) definitions when they are not.</p>
<p>This simple technique works for the case when there is zero or one implementations. To support multiple <code>#[pymethods]</code> for a <code>#[pyclass]</code> (in the [<code>multiple-pymethods</code>] feature), a registry mechanism provided by the <a href="https://github.com/dtolnay/inventory"><code>inventory</code></a> crate is used instead. This collects <code>impl</code>s at library load time, but isn't supported on all platforms. See <a href="https://github.com/dtolnay/inventory#how-it-works">inventory: how it works</a> for more details.</p>
<p>The <code>#[pyclass]</code> macro expands to roughly the code seen below. The <code>PyClassImplCollector</code> is the type used internally by PyO3 for dtolnay specialization:</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(not(feature = &quot;multiple-pymethods&quot;))] {
<span class="boring">use pyo3::prelude::*;
</span>// Note: the implementation differs slightly with the `multiple-pymethods` feature enabled.
struct MyClass {
<span class="boring">    #[allow(dead_code)]
</span>    num: i32,
}
unsafe impl pyo3::type_object::PyTypeInfo for MyClass {
    type AsRefTarget = pyo3::PyCell&lt;Self&gt;;
    const NAME: &amp;'static str = &quot;MyClass&quot;;
    const MODULE: ::std::option::Option&lt;&amp;'static str&gt; = ::std::option::Option::None;
    #[inline]
    fn type_object_raw(py: pyo3::Python&lt;'_&gt;) -&gt; *mut pyo3::ffi::PyTypeObject {
        &lt;Self as pyo3::impl_::pyclass::PyClassImpl&gt;::lazy_type_object()
            .get_or_init(py)
            .as_type_ptr()
    }
}

impl pyo3::PyClass for MyClass {
    type Frozen = pyo3::pyclass::boolean_struct::False;
}

impl&lt;'a, 'py&gt; pyo3::impl_::extract_argument::PyFunctionArgument&lt;'a, 'py&gt; for &amp;'a MyClass
{
    type Holder = ::std::option::Option&lt;pyo3::PyRef&lt;'py, MyClass&gt;&gt;;

    #[inline]
    fn extract(obj: &amp;'py pyo3::PyAny, holder: &amp;'a mut Self::Holder) -&gt; pyo3::PyResult&lt;Self&gt; {
        pyo3::impl_::extract_argument::extract_pyclass_ref(obj, holder)
    }
}

impl&lt;'a, 'py&gt; pyo3::impl_::extract_argument::PyFunctionArgument&lt;'a, 'py&gt; for &amp;'a mut MyClass
{
    type Holder = ::std::option::Option&lt;pyo3::PyRefMut&lt;'py, MyClass&gt;&gt;;

    #[inline]
    fn extract(obj: &amp;'py pyo3::PyAny, holder: &amp;'a mut Self::Holder) -&gt; pyo3::PyResult&lt;Self&gt; {
        pyo3::impl_::extract_argument::extract_pyclass_ref_mut(obj, holder)
    }
}

impl pyo3::IntoPy&lt;PyObject&gt; for MyClass {
    fn into_py(self, py: pyo3::Python&lt;'_&gt;) -&gt; pyo3::PyObject {
        pyo3::IntoPy::into_py(pyo3::Py::new(py, self).unwrap(), py)
    }
}

impl pyo3::impl_::pyclass::PyClassImpl for MyClass {
    const DOC: &amp;'static str = &quot;Class for demonstration\u{0}&quot;;
    const IS_BASETYPE: bool = false;
    const IS_SUBCLASS: bool = false;
    type Layout = PyCell&lt;MyClass&gt;;
    type BaseType = PyAny;
    type ThreadChecker = pyo3::impl_::pyclass::ThreadCheckerStub&lt;MyClass&gt;;
    type PyClassMutability = &lt;&lt;pyo3::PyAny as pyo3::impl_::pyclass::PyClassBaseType&gt;::PyClassMutability as pyo3::impl_::pycell::PyClassMutability&gt;::MutableChild;
    type Dict = pyo3::impl_::pyclass::PyClassDummySlot;
    type WeakRef = pyo3::impl_::pyclass::PyClassDummySlot;
    type BaseNativeType = pyo3::PyAny;

    fn items_iter() -&gt; pyo3::impl_::pyclass::PyClassItemsIter {
        use pyo3::impl_::pyclass::*;
        let collector = PyClassImplCollector::&lt;MyClass&gt;::new();
        static INTRINSIC_ITEMS: PyClassItems = PyClassItems { slots: &amp;[], methods: &amp;[] };
        PyClassItemsIter::new(&amp;INTRINSIC_ITEMS, collector.py_methods())
    }

    fn lazy_type_object() -&gt; &amp;'static pyo3::impl_::pyclass::LazyTypeObject&lt;MyClass&gt; {
        use pyo3::impl_::pyclass::LazyTypeObject;
        static TYPE_OBJECT: LazyTypeObject&lt;MyClass&gt; = LazyTypeObject::new();
        &amp;TYPE_OBJECT
    }
}

Python::with_gil(|py| {
    let cls = py.get_type::&lt;MyClass&gt;();
    pyo3::py_run!(py, cls, &quot;assert cls.__name__ == 'MyClass'&quot;)
});
}
<span class="boring">}</span></code></pre></pre>

                    <div id="giscus-container"></div>
                </main>

                <nav class="nav-wrapper" aria-label="Page navigation">
                    <!-- Mobile navigation buttons -->
                    <a rel="prev" href="../../../rust/pyo3/pythonfunctions/error_handling.html" class="mobile-nav-chapters previous"
                        title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../../../rust/pyo3/python_classes/class_customization.html" class="mobile-nav-chapters next"
                        title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>

                    <div style="clear: both"></div>
                </nav>
            </div>
        </div>

        <nav class="nav-wide-wrapper" aria-label="Page navigation">
            <a rel="prev" href="../../../rust/pyo3/pythonfunctions/error_handling.html" class="nav-chapters previous" title="Previous chapter"
                aria-label="Previous chapter" aria-keyshortcuts="Left">
                <i class="fa fa-angle-left"></i>
            </a>

            <a rel="next" href="../../../rust/pyo3/python_classes/class_customization.html" class="nav-chapters next" title="Next chapter"
                aria-label="Next chapter" aria-keyshortcuts="Right">
                <i class="fa fa-angle-right"></i>
            </a>
        </nav>

    </div>




    <script type="text/javascript">
        window.playground_copyable = true;
    </script>

    <script src="../../../ace.js" type="text/javascript" charset="utf-8"></script>
    <script src="../../../editor.js" type="text/javascript" charset="utf-8"></script>
    <script src="../../../mode-rust.js" type="text/javascript" charset="utf-8"></script>
    <script src="../../../theme-dawn.js" type="text/javascript" charset="utf-8"></script>
    <script src="../../../theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>

    <script src="../../../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="../../../mark.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="../../../searcher.js" type="text/javascript" charset="utf-8"></script>

    <script src="../../../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="../../../highlight.js" type="text/javascript" charset="utf-8"></script>
    <script src="../../../book.js" type="text/javascript" charset="utf-8"></script>
    <script type="text/javascript" charset="utf-8">
        var pagePath = "rust/pyo3/python_classes/pre.md"
    </script>


    <!-- Custom JS scripts -->
    <script type="text/javascript" src="../../../assets/custom.js"></script>
    <script type="text/javascript" src="../../../assets/bigPicture.js"></script>


</body>

</html>