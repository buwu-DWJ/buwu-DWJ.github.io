<!DOCTYPE HTML>
<html lang="chs" class="sidebar-visible no-js ayu">

<head>
    <!-- Book generated using mdBook -->
    <meta charset="UTF-8">
    <title>HTML - 布武不舞</title>


    <!-- Custom HTML head -->
    
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#ffffff" />

    <link rel="icon" href="../../favicon.svg">
    <link rel="shortcut icon" href="../../favicon.png">
    <link rel="stylesheet" href="../../css/variables.css">
    <link rel="stylesheet" href="../../css/general.css">
    <link rel="stylesheet" href="../../css/chrome.css">
    <link rel="stylesheet" href="../../css/print.css" media="print">

    <!-- Fonts -->
    <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
    <link rel="stylesheet" href="../../fonts/fonts.css">

    <!-- Highlight.js Stylesheets -->
    <link rel="stylesheet" href="../../highlight.css">
    <link rel="stylesheet" href="../../tomorrow-night.css">
    <link rel="stylesheet" href="../../ayu-highlight.css">

    <!-- Custom theme stylesheets -->
    <link rel="stylesheet" href="../../theme/style3.css">


</head>

<body>

    <!-- Provide site root to javascript -->
    <script type="text/javascript">
        var path_to_root = "../../";
        var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "ayu";
    </script>

    <!-- Work around some values being stored in localStorage wrapped in quotes -->
    <script type="text/javascript">
        try {
            var theme = localStorage.getItem('mdbook-theme');
            var sidebar = localStorage.getItem('mdbook-sidebar');
            if (theme.startsWith('"') && theme.endsWith('"')) {
                localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
            }
            if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
            }
        } catch (e) { }
    </script>

    <!-- Set the theme before any content is loaded, prevents flash -->
    <script type="text/javascript">
        var theme;
        try { theme = localStorage.getItem('mdbook-theme'); } catch (e) { }
        if (theme === null || theme === undefined) { theme = default_theme; }
        var html = document.querySelector('html');
        html.classList.remove('no-js')
        html.classList.remove('ayu')
        html.classList.add(theme);
        html.classList.add('js');
    </script>

    <!-- Hide / unhide sidebar before it is displayed -->
    <script type="text/javascript">
        var html = document.querySelector('html');
        var sidebar = 'hidden';
        if (document.body.clientWidth >= 1080) {
            try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch (e) { }
            sidebar = sidebar || 'visible';
        }
        html.classList.remove('sidebar-visible');
        html.classList.add("sidebar-" + sidebar);
    </script>

    <nav id="sidebar" class="sidebar" aria-label="Table of contents">
        <div class="sidebar-scrollbox">
            <ol class="chapter"><li class="chapter-item affix "><a href="../../pre.html">目录</a></li><li class="chapter-item affix "><li class="part-title">Summary</li><li class="chapter-item "><a href="../../markdown/markdown.html"><strong aria-hidden="true">1.</strong> Markdown&LaTeX</a></li><li class="chapter-item expanded "><a href="../../python/python.html"><strong aria-hidden="true">2.</strong> Python</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../python/win32com/pre.html"><strong aria-hidden="true">2.1.</strong> win32com</a></li><li class="chapter-item expanded "><a href="../../python/crawler/pre.html"><strong aria-hidden="true">2.2.</strong> crawler</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../python/crawler/html.html" class="active"><strong aria-hidden="true">2.2.1.</strong> HTML</a></li><li class="chapter-item "><a href="../../python/crawler/BeautifulSoup.html"><strong aria-hidden="true">2.2.2.</strong> BeautifulSoup</a></li><li class="chapter-item "><a href="../../python/crawler/re.html"><strong aria-hidden="true">2.2.3.</strong> re</a></li><li class="chapter-item "><a href="../../python/crawler/xpath.html"><strong aria-hidden="true">2.2.4.</strong> XPath</a></li><li class="chapter-item "><a href="../../python/crawler/css_selector.html"><strong aria-hidden="true">2.2.5.</strong> CSS_selector</a></li><li class="chapter-item "><a href="../../python/crawler/dash.html"><strong aria-hidden="true">2.2.6.</strong> dash</a></li></ol></li><li class="chapter-item "><a href="../../python/pytorch/pytorch.html"><strong aria-hidden="true">2.3.</strong> pytorch</a></li><li class="chapter-item "><a href="../../python/np_pd/np_pd.html"><strong aria-hidden="true">2.4.</strong> others</a></li><li class="chapter-item "><a href="../../python/python之禅/pre.html"><strong aria-hidden="true">2.5.</strong> python之禅</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../python/python之禅/optim.html"><strong aria-hidden="true">2.5.1.</strong> 结构上优化运行速度</a></li><li class="chapter-item "><a href="../../python/python之禅/python_optim.html"><strong aria-hidden="true">2.5.2.</strong> 其他细节</a></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">2.6.</strong> SICP_for_Python</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../python/sicp_py/sicp-py-zh-master/ch1.html"><strong aria-hidden="true">2.6.1.</strong> 第一章 使用函数构建抽象</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../python/sicp_py/sicp-py-zh-master/1.1.html"><strong aria-hidden="true">2.6.1.1.</strong> 1.1 引言</a></li><li class="chapter-item "><a href="../../python/sicp_py/sicp-py-zh-master/1.2.html"><strong aria-hidden="true">2.6.1.2.</strong> 1.2 编程元素</a></li><li class="chapter-item "><a href="../../python/sicp_py/sicp-py-zh-master/1.3.html"><strong aria-hidden="true">2.6.1.3.</strong> 1.3 定义新的函数</a></li><li class="chapter-item "><a href="../../python/sicp_py/sicp-py-zh-master/1.4.html"><strong aria-hidden="true">2.6.1.4.</strong> 1.4 实践指南：函数的艺术</a></li><li class="chapter-item "><a href="../../python/sicp_py/sicp-py-zh-master/1.5.html"><strong aria-hidden="true">2.6.1.5.</strong> 1.5 控制</a></li><li class="chapter-item "><a href="../../python/sicp_py/sicp-py-zh-master/1.6.html"><strong aria-hidden="true">2.6.1.6.</strong> 1.6 高阶函数</a></li></ol></li><li class="chapter-item "><a href="../../python/sicp_py/sicp-py-zh-master/ch2.html"><strong aria-hidden="true">2.6.2.</strong> 第二章 使用对象构建抽象</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../python/sicp_py/sicp-py-zh-master/2.1.html"><strong aria-hidden="true">2.6.2.1.</strong> 2.1 引言</a></li><li class="chapter-item "><a href="../../python/sicp_py/sicp-py-zh-master/2.2.html"><strong aria-hidden="true">2.6.2.2.</strong> 2.2 数据抽象</a></li><li class="chapter-item "><a href="../../python/sicp_py/sicp-py-zh-master/2.3.html"><strong aria-hidden="true">2.6.2.3.</strong> 2.3 序列</a></li><li class="chapter-item "><a href="../../python/sicp_py/sicp-py-zh-master/2.4.html"><strong aria-hidden="true">2.6.2.4.</strong> 2.4 可变数据</a></li><li class="chapter-item "><a href="../../python/sicp_py/sicp-py-zh-master/2.5.html"><strong aria-hidden="true">2.6.2.5.</strong> 2.5 面向对象编程</a></li><li class="chapter-item "><a href="../../python/sicp_py/sicp-py-zh-master/2.6.html"><strong aria-hidden="true">2.6.2.6.</strong> 2.6 实现类和对象</a></li><li class="chapter-item "><a href="../../python/sicp_py/sicp-py-zh-master/2.7.html"><strong aria-hidden="true">2.6.2.7.</strong> 2.7 泛用方法</a></li></ol></li><li class="chapter-item "><a href="../../python/sicp_py/sicp-py-zh-master/ch3.html"><strong aria-hidden="true">2.6.3.</strong> 第三章 计算机程序的构造和解释</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../python/sicp_py/sicp-py-zh-master/3.1.html"><strong aria-hidden="true">2.6.3.1.</strong> 3.1 引言</a></li><li class="chapter-item "><a href="../../python/sicp_py/sicp-py-zh-master/3.2.html"><strong aria-hidden="true">2.6.3.2.</strong> 3.2 函数和所生成的过程</a></li><li class="chapter-item "><a href="../../python/sicp_py/sicp-py-zh-master/3.3.html"><strong aria-hidden="true">2.6.3.3.</strong> 3.3 递归数据结构</a></li><li class="chapter-item "><a href="../../python/sicp_py/sicp-py-zh-master/3.4.html"><strong aria-hidden="true">2.6.3.4.</strong> 3.4 异常</a></li><li class="chapter-item "><a href="../../python/sicp_py/sicp-py-zh-master/3.5.html"><strong aria-hidden="true">2.6.3.5.</strong> 3.5 组合语言的解释器</a></li><li class="chapter-item "><a href="../../python/sicp_py/sicp-py-zh-master/3.6.html"><strong aria-hidden="true">2.6.3.6.</strong> 3.6 抽象语言的解释器</a></li></ol></li><li class="chapter-item "><a href="../../python/sicp_py/sicp-py-zh-master/ch4.html"><strong aria-hidden="true">2.6.4.</strong> 第四章 分布式和并行计算</a></li><li class="chapter-item "><a href="../../python/sicp_py/sicp-py-zh-master/ch5.html"><strong aria-hidden="true">2.6.5.</strong> 第五章 序列和协程</a></li></ol></li></ol></li><li class="chapter-item "><a href="../../cpp/pre.html"><strong aria-hidden="true">3.</strong> CPP</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><div><strong aria-hidden="true">3.1.</strong> cpp_primer_plus笔记</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../cpp/cpp_primer_plus/1.基础/index.html"><strong aria-hidden="true">3.1.1.</strong> 基础</a></li><li class="chapter-item "><a href="../../cpp/cpp_primer_plus/2.函数/index.html"><strong aria-hidden="true">3.1.2.</strong> 函数</a></li><li class="chapter-item "><a href="../../cpp/cpp_primer_plus/3.内存模型和名称空间/index.html"><strong aria-hidden="true">3.1.3.</strong> 内存模型和名称空间</a></li><li class="chapter-item "><a href="../../cpp/cpp_primer_plus/4.对象和类/index.html"><strong aria-hidden="true">3.1.4.</strong> 对象和类</a></li><li class="chapter-item "><a href="../../cpp/cpp_primer_plus/5.使用类/index.html"><strong aria-hidden="true">3.1.5.</strong> 使用类</a></li><li class="chapter-item "><a href="../../cpp/cpp_primer_plus/6.类和动态内存分配/index.html"><strong aria-hidden="true">3.1.6.</strong> 类和动态内存分配</a></li><li class="chapter-item "><a href="../../cpp/cpp_primer_plus/7.类继承/index.html"><strong aria-hidden="true">3.1.7.</strong> 类继承</a></li><li class="chapter-item "><a href="../../cpp/cpp_primer_plus/8.C++中的代码重用/index.html"><strong aria-hidden="true">3.1.8.</strong> 代码重用</a></li><li class="chapter-item "><a href="../../cpp/cpp_primer_plus/9.友元、异常和其他/index.html"><strong aria-hidden="true">3.1.9.</strong> 友元、异常及其他</a></li></ol></li></ol></li><li class="chapter-item "><a href="../../rust/pre.html"><strong aria-hidden="true">4.</strong> Rust</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../rust/rust_holy/pre.html"><strong aria-hidden="true">4.1.</strong> Rust圣经👿摘要</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../rust/rust_holy/basic/pre.html"><strong aria-hidden="true">4.1.1.</strong> 基础知识</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../rust/rust_holy/basic/basic.html"><strong aria-hidden="true">4.1.1.1.</strong> 安装及其他</a></li><li class="chapter-item "><a href="../../rust/rust_holy/basic/basic_types/pre.html"><strong aria-hidden="true">4.1.1.2.</strong> 基本类型</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../rust/rust_holy/basic/basic_types/basic_types.html"><strong aria-hidden="true">4.1.1.2.1.</strong> 数值类型</a></li><li class="chapter-item "><a href="../../rust/rust_holy/basic/basic_types/char.html"><strong aria-hidden="true">4.1.1.2.2.</strong> 字符,布尔,单元类型</a></li><li class="chapter-item "><a href="../../rust/rust_holy/basic/basic_types/statement.html"><strong aria-hidden="true">4.1.1.2.3.</strong> 语句和表达式</a></li><li class="chapter-item "><a href="../../rust/rust_holy/basic/basic_types/function.html"><strong aria-hidden="true">4.1.1.2.4.</strong> 函数</a></li></ol></li><li class="chapter-item "><a href="../../rust/rust_holy/basic/variable.html"><strong aria-hidden="true">4.1.1.3.</strong> 变量绑定与解构</a></li><li class="chapter-item "><a href="../../rust/rust_holy/basic/ownership/pre.html"><strong aria-hidden="true">4.1.1.4.</strong> 所有权,引用与借用</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../rust/rust_holy/basic/ownership/ownership.html"><strong aria-hidden="true">4.1.1.4.1.</strong> 所有权</a></li><li class="chapter-item "><a href="../../rust/rust_holy/basic/ownership/borrowing.html"><strong aria-hidden="true">4.1.1.4.2.</strong> 引用与借用</a></li></ol></li><li class="chapter-item "><a href="../../rust/rust_holy/basic/compound_type/pre.html"><strong aria-hidden="true">4.1.1.5.</strong> 复合类型</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../rust/rust_holy/basic/compound_type/string_slice.html"><strong aria-hidden="true">4.1.1.5.1.</strong> 字符串与切片</a></li><li class="chapter-item "><a href="../../rust/rust_holy/basic/compound_type/tuple.html"><strong aria-hidden="true">4.1.1.5.2.</strong> 元组</a></li><li class="chapter-item "><a href="../../rust/rust_holy/basic/compound_type/struct.html"><strong aria-hidden="true">4.1.1.5.3.</strong> 结构体</a></li><li class="chapter-item "><a href="../../rust/rust_holy/basic/compound_type/enum.html"><strong aria-hidden="true">4.1.1.5.4.</strong> 枚举</a></li><li class="chapter-item "><a href="../../rust/rust_holy/basic/compound_type/array.html"><strong aria-hidden="true">4.1.1.5.5.</strong> 数组</a></li></ol></li><li class="chapter-item "><a href="../../rust/rust_holy/basic/flow_control.html"><strong aria-hidden="true">4.1.1.6.</strong> 流式控制</a></li><li class="chapter-item "><a href="../../rust/rust_holy/basic/match_pattern/pre.html"><strong aria-hidden="true">4.1.1.7.</strong> 模式匹配</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../rust/rust_holy/basic/match_pattern/if_let.html"><strong aria-hidden="true">4.1.1.7.1.</strong> if_let</a></li><li class="chapter-item "><a href="../../rust/rust_holy/basic/match_pattern/option.html"><strong aria-hidden="true">4.1.1.7.2.</strong> option</a></li><li class="chapter-item "><a href="../../rust/rust_holy/basic/match_pattern/pattern_match.html"><strong aria-hidden="true">4.1.1.7.3.</strong> 模式适用场景</a></li><li class="chapter-item "><a href="../../rust/rust_holy/basic/match_pattern/all_patterns.html"><strong aria-hidden="true">4.1.1.7.4.</strong> 全模式列表</a></li></ol></li><li class="chapter-item "><a href="../../rust/rust_holy/basic/method.html"><strong aria-hidden="true">4.1.1.8.</strong> 方法method</a></li><li class="chapter-item "><a href="../../rust/rust_holy/basic/generics_and_traits/pre.html"><strong aria-hidden="true">4.1.1.9.</strong> 泛型和特征</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../rust/rust_holy/basic/generics_and_traits/generic.html"><strong aria-hidden="true">4.1.1.9.1.</strong> 泛型Generics</a></li><li class="chapter-item "><a href="../../rust/rust_holy/basic/generics_and_traits/trait.html"><strong aria-hidden="true">4.1.1.9.2.</strong> 特征Traits</a></li><li class="chapter-item "><a href="../../rust/rust_holy/basic/generics_and_traits/trait_object.html"><strong aria-hidden="true">4.1.1.9.3.</strong> 特征对象</a></li><li class="chapter-item "><a href="../../rust/rust_holy/basic/generics_and_traits/advance_trait.html"><strong aria-hidden="true">4.1.1.9.4.</strong> 深入特征</a></li></ol></li><li class="chapter-item "><a href="../../rust/rust_holy/basic/collections/pre.html"><strong aria-hidden="true">4.1.1.10.</strong> 集合</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../rust/rust_holy/basic/collections/vector.html"><strong aria-hidden="true">4.1.1.10.1.</strong> 动态数组</a></li><li class="chapter-item "><a href="../../rust/rust_holy/basic/collections/hashmap.html"><strong aria-hidden="true">4.1.1.10.2.</strong> hashmap</a></li></ol></li><li class="chapter-item "><a href="../../rust/rust_holy/basic/lifetime.html"><strong aria-hidden="true">4.1.1.11.</strong> 生命周期🆘</a></li><li class="chapter-item "><a href="../../rust/rust_holy/basic/result_error/pre.html"><strong aria-hidden="true">4.1.1.12.</strong> 返回值与错误处理</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../rust/rust_holy/basic/result_error/panic.html"><strong aria-hidden="true">4.1.1.12.1.</strong> panic!深入</a></li><li class="chapter-item "><a href="../../rust/rust_holy/basic/result_error/result.html"><strong aria-hidden="true">4.1.1.12.2.</strong> 返回值Result</a></li></ol></li><li class="chapter-item "><a href="../../rust/rust_holy/basic/crate_module/pre.html"><strong aria-hidden="true">4.1.1.13.</strong> 包和模块</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../rust/rust_holy/basic/crate_module/crate.html"><strong aria-hidden="true">4.1.1.13.1.</strong> 包Crate</a></li><li class="chapter-item "><a href="../../rust/rust_holy/basic/crate_module/module.html"><strong aria-hidden="true">4.1.1.13.2.</strong> 模块Module</a></li><li class="chapter-item "><a href="../../rust/rust_holy/basic/crate_module/use.html"><strong aria-hidden="true">4.1.1.13.3.</strong> 使用use及受限可见性</a></li></ol></li><li class="chapter-item "><a href="../../rust/rust_holy/basic/comment.html"><strong aria-hidden="true">4.1.1.14.</strong> 注释和文档</a></li><li class="chapter-item "><a href="../../rust/rust_holy/basic/converse.html"><strong aria-hidden="true">4.1.1.15.</strong> 类型转换</a></li><li class="chapter-item "><a href="../../rust/rust_holy/basic/formatted_output.html"><strong aria-hidden="true">4.1.1.16.</strong> 格式化输出</a></li></ol></li><li class="chapter-item "><a href="../../rust/rust_holy/basic-practice/intro.html"><strong aria-hidden="true">4.1.2.</strong> 入门实战：构建一个简单命令行程序</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../rust/rust_holy/basic-practice/base-features.html"><strong aria-hidden="true">4.1.2.1.</strong> 基本功能</a></li><li class="chapter-item "><a href="../../rust/rust_holy/basic-practice/refactoring.html"><strong aria-hidden="true">4.1.2.2.</strong> 增加模块化和错误处理</a></li><li class="chapter-item "><a href="../../rust/rust_holy/basic-practice/tests.html"><strong aria-hidden="true">4.1.2.3.</strong> 测试驱动开发</a></li><li class="chapter-item "><a href="../../rust/rust_holy/basic-practice/envs.html"><strong aria-hidden="true">4.1.2.4.</strong> 使用环境变量</a></li><li class="chapter-item "><a href="../../rust/rust_holy/basic-practice/iterators.html"><strong aria-hidden="true">4.1.2.5.</strong> 使用迭代器来改进程序(可选)</a></li></ol></li><li class="chapter-item "><a href="../../rust/rust_holy/advance/intro.html"><strong aria-hidden="true">4.1.3.</strong> Rust 高级进阶</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../rust/rust_holy/advance/lifetime/intro.html"><strong aria-hidden="true">4.1.3.1.</strong> 生命周期</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../rust/rust_holy/advance/lifetime/advance.html"><strong aria-hidden="true">4.1.3.1.1.</strong> 深入生命周期</a></li><li class="chapter-item "><a href="../../rust/rust_holy/advance/lifetime/static.html"><strong aria-hidden="true">4.1.3.1.2.</strong> &'static 和 T: 'static</a></li></ol></li><li class="chapter-item "><a href="../../rust/rust_holy/advance/functional-programing/intro.html"><strong aria-hidden="true">4.1.3.2.</strong> 函数式编程: 闭包、迭代器</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../rust/rust_holy/advance/functional-programing/closure.html"><strong aria-hidden="true">4.1.3.2.1.</strong> 闭包 Closure</a></li><li class="chapter-item "><a href="../../rust/rust_holy/advance/functional-programing/iterator.html"><strong aria-hidden="true">4.1.3.2.2.</strong> 迭代器 Iterator</a></li></ol></li><li class="chapter-item "><a href="../../rust/rust_holy/advance/into-types/intro.html"><strong aria-hidden="true">4.1.3.3.</strong> 深入类型</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../rust/rust_holy/advance/into-types/custom-type.html"><strong aria-hidden="true">4.1.3.3.1.</strong> newtype 和 类型别名</a></li><li class="chapter-item "><a href="../../rust/rust_holy/advance/into-types/sized.html"><strong aria-hidden="true">4.1.3.3.2.</strong> Sized 和不定长类型 DST</a></li><li class="chapter-item "><a href="../../rust/rust_holy/advance/into-types/enum-int.html"><strong aria-hidden="true">4.1.3.3.3.</strong> 枚举和整数</a></li></ol></li><li class="chapter-item "><a href="../../rust/rust_holy/advance/smart-pointer/intro.html"><strong aria-hidden="true">4.1.3.4.</strong> 智能指针</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../rust/rust_holy/advance/smart-pointer/box.html"><strong aria-hidden="true">4.1.3.4.1.</strong> Box堆对象分配</a></li><li class="chapter-item "><a href="../../rust/rust_holy/advance/smart-pointer/deref.html"><strong aria-hidden="true">4.1.3.4.2.</strong> Deref 解引用</a></li><li class="chapter-item "><a href="../../rust/rust_holy/advance/smart-pointer/drop.html"><strong aria-hidden="true">4.1.3.4.3.</strong> Drop 释放资源</a></li><li class="chapter-item "><a href="../../rust/rust_holy/advance/smart-pointer/rc-arc.html"><strong aria-hidden="true">4.1.3.4.4.</strong> Rc 与 Arc 实现 1vN 所有权机制</a></li><li class="chapter-item "><a href="../../rust/rust_holy/advance/smart-pointer/cell-refcell.html"><strong aria-hidden="true">4.1.3.4.5.</strong> Cell 与 RefCell 内部可变性</a></li></ol></li><li class="chapter-item "><a href="../../rust/rust_holy/advance/circle-self-ref/intro.html"><strong aria-hidden="true">4.1.3.5.</strong> 循环引用与自引用</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../rust/rust_holy/advance/circle-self-ref/circle-reference.html"><strong aria-hidden="true">4.1.3.5.1.</strong> Weak 与循环引用</a></li><li class="chapter-item "><a href="../../rust/rust_holy/advance/circle-self-ref/self-referential.html"><strong aria-hidden="true">4.1.3.5.2.</strong> 结构体中的自引用</a></li></ol></li><li class="chapter-item "><a href="../../rust/rust_holy/advance/concurrency-with-threads/intro.html"><strong aria-hidden="true">4.1.3.6.</strong> 多线程并发编程</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../rust/rust_holy/advance/concurrency-with-threads/concurrency-parallelism.html"><strong aria-hidden="true">4.1.3.6.1.</strong> 并发和并行</a></li><li class="chapter-item "><a href="../../rust/rust_holy/advance/concurrency-with-threads/thread.html"><strong aria-hidden="true">4.1.3.6.2.</strong> 使用多线程</a></li><li class="chapter-item "><a href="../../rust/rust_holy/advance/concurrency-with-threads/message-passing.html"><strong aria-hidden="true">4.1.3.6.3.</strong> 线程同步：消息传递</a></li><li class="chapter-item "><a href="../../rust/rust_holy/advance/concurrency-with-threads/sync1.html"><strong aria-hidden="true">4.1.3.6.4.</strong> 线程同步：锁、Condvar 和信号量</a></li><li class="chapter-item "><a href="../../rust/rust_holy/advance/concurrency-with-threads/sync2.html"><strong aria-hidden="true">4.1.3.6.5.</strong> 线程同步：Atomic 原子操作与内存顺序</a></li><li class="chapter-item "><a href="../../rust/rust_holy/advance/concurrency-with-threads/send-sync.html"><strong aria-hidden="true">4.1.3.6.6.</strong> 基于 Send 和 Sync 的线程安全</a></li><li class="chapter-item "><a href="../../rust/rust_holy/advance/concurrency-with-threads/web-server.html"><strong aria-hidden="true">4.1.3.6.7.</strong> 实践应用：多线程 Web 服务器 todo</a></li></ol></li><li class="chapter-item "><a href="../../rust/rust_holy/advance/global-variable.html"><strong aria-hidden="true">4.1.3.7.</strong> 全局变量</a></li><li class="chapter-item "><a href="../../rust/rust_holy/advance/errors.html"><strong aria-hidden="true">4.1.3.8.</strong> 错误处理</a></li><li class="chapter-item "><a href="../../rust/rust_holy/advance/unsafe/intro.html"><strong aria-hidden="true">4.1.3.9.</strong> Unsafe Rust</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../rust/rust_holy/advance/unsafe/superpowers.html"><strong aria-hidden="true">4.1.3.9.1.</strong> 五种兵器</a></li><li class="chapter-item "><a href="../../rust/rust_holy/advance/unsafe/inline-asm.html"><strong aria-hidden="true">4.1.3.9.2.</strong> 内联汇编 todo</a></li></ol></li><li class="chapter-item "><a href="../../rust/rust_holy/advance/macro.html"><strong aria-hidden="true">4.1.3.10.</strong> Macro 宏编程</a></li></ol></li><li class="chapter-item "><a href="../../rust/rust_holy/async-rust/intro.html"><strong aria-hidden="true">4.1.4.</strong> Rust 异步编程</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../rust/rust_holy/async-rust/async/intro.html"><strong aria-hidden="true">4.1.4.1.</strong> async/await 异步编程</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../rust/rust_holy/async-rust/async/getting-started.html"><strong aria-hidden="true">4.1.4.1.1.</strong> async 编程入门</a></li><li class="chapter-item "><a href="../../rust/rust_holy/async-rust/async/future-excuting.html"><strong aria-hidden="true">4.1.4.1.2.</strong> 底层探秘: Future 执行与任务调度</a></li><li class="chapter-item "><a href="../../rust/rust_holy/async-rust/async/pin-unpin.html"><strong aria-hidden="true">4.1.4.1.3.</strong> 定海神针 Pin 和 Unpin</a></li><li class="chapter-item "><a href="../../rust/rust_holy/async-rust/async/async-await.html"><strong aria-hidden="true">4.1.4.1.4.</strong> async/await 和 Stream 流处理</a></li><li class="chapter-item "><a href="../../rust/rust_holy/async-rust/async/multi-futures-simultaneous.html"><strong aria-hidden="true">4.1.4.1.5.</strong> 同时运行多个 Future</a></li><li class="chapter-item "><a href="../../rust/rust_holy/async-rust/async/pain-points-and-workarounds.html"><strong aria-hidden="true">4.1.4.1.6.</strong> 一些疑难问题的解决办法</a></li><li class="chapter-item "><a href="../../rust/rust_holy/async-rust/async/web-server.html"><strong aria-hidden="true">4.1.4.1.7.</strong> 实践应用：Async Web 服务器</a></li></ol></li><li class="chapter-item "><a href="../../rust/rust_holy/async-rust/tokio/intro.html"><strong aria-hidden="true">4.1.4.2.</strong> Tokio 使用指南</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../rust/rust_holy/async-rust/tokio/overview.html"><strong aria-hidden="true">4.1.4.2.1.</strong> tokio 概览</a></li><li class="chapter-item "><a href="../../rust/rust_holy/async-rust/tokio/getting-startted.html"><strong aria-hidden="true">4.1.4.2.2.</strong> 使用初印象</a></li><li class="chapter-item "><a href="../../rust/rust_holy/async-rust/tokio/spawning.html"><strong aria-hidden="true">4.1.4.2.3.</strong> 创建异步任务</a></li><li class="chapter-item "><a href="../../rust/rust_holy/async-rust/tokio/shared-state.html"><strong aria-hidden="true">4.1.4.2.4.</strong> 共享状态</a></li><li class="chapter-item "><a href="../../rust/rust_holy/async-rust/tokio/channels.html"><strong aria-hidden="true">4.1.4.2.5.</strong> 消息传递</a></li><li class="chapter-item "><a href="../../rust/rust_holy/async-rust/tokio/io.html"><strong aria-hidden="true">4.1.4.2.6.</strong> I/O</a></li><li class="chapter-item "><a href="../../rust/rust_holy/async-rust/tokio/frame.html"><strong aria-hidden="true">4.1.4.2.7.</strong> 解析数据帧</a></li><li class="chapter-item "><a href="../../rust/rust_holy/async-rust/tokio/async.html"><strong aria-hidden="true">4.1.4.2.8.</strong> 深入 async</a></li><li class="chapter-item "><a href="../../rust/rust_holy/async-rust/tokio/select.html"><strong aria-hidden="true">4.1.4.2.9.</strong> select</a></li><li class="chapter-item "><a href="../../rust/rust_holy/async-rust/tokio/stream.html"><strong aria-hidden="true">4.1.4.2.10.</strong> 类似迭代器的 Stream</a></li><li class="chapter-item "><a href="../../rust/rust_holy/async-rust/tokio/graceful-shutdown.html"><strong aria-hidden="true">4.1.4.2.11.</strong> 优雅的关闭</a></li><li class="chapter-item "><a href="../../rust/rust_holy/async-rust/tokio/bridging-with-sync.html"><strong aria-hidden="true">4.1.4.2.12.</strong> 异步跟同步共存</a></li></ol></li></ol></li><li class="chapter-item "><a href="../../rust/rust_holy/cargo/intro.html"><strong aria-hidden="true">4.1.5.</strong> Cargo 使用指南</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../rust/rust_holy/cargo/getting-started.html"><strong aria-hidden="true">4.1.5.1.</strong> 上手使用</a></li><li class="chapter-item "><a href="../../rust/rust_holy/cargo/guide/intro.html"><strong aria-hidden="true">4.1.5.2.</strong> 基础指南</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../rust/rust_holy/cargo/guide/why-exist.html"><strong aria-hidden="true">4.1.5.2.1.</strong> 为何会有 Cargo</a></li><li class="chapter-item "><a href="../../rust/rust_holy/cargo/guide/download-package.html"><strong aria-hidden="true">4.1.5.2.2.</strong> 下载并构建 Package</a></li><li class="chapter-item "><a href="../../rust/rust_holy/cargo/guide/dependencies.html"><strong aria-hidden="true">4.1.5.2.3.</strong> 添加依赖</a></li><li class="chapter-item "><a href="../../rust/rust_holy/cargo/guide/package-layout.html"><strong aria-hidden="true">4.1.5.2.4.</strong> Package 目录结构</a></li><li class="chapter-item "><a href="../../rust/rust_holy/cargo/guide/cargo-toml-lock.html"><strong aria-hidden="true">4.1.5.2.5.</strong> Cargo.toml vs Cargo.lock</a></li><li class="chapter-item "><a href="../../rust/rust_holy/cargo/guide/tests-ci.html"><strong aria-hidden="true">4.1.5.2.6.</strong> 测试和 CI</a></li><li class="chapter-item "><a href="../../rust/rust_holy/cargo/guide/cargo-cache.html"><strong aria-hidden="true">4.1.5.2.7.</strong> Cargo 缓存</a></li><li class="chapter-item "><a href="../../rust/rust_holy/cargo/guide/build-cache.html"><strong aria-hidden="true">4.1.5.2.8.</strong> Build 缓存</a></li></ol></li><li class="chapter-item "><a href="../../rust/rust_holy/cargo/reference/intro.html"><strong aria-hidden="true">4.1.5.3.</strong> 进阶指南</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../rust/rust_holy/cargo/reference/specify-deps.html"><strong aria-hidden="true">4.1.5.3.1.</strong> 指定依赖项</a></li><li class="chapter-item "><a href="../../rust/rust_holy/cargo/reference/deps-overriding.html"><strong aria-hidden="true">4.1.5.3.2.</strong> 依赖覆盖</a></li><li class="chapter-item "><a href="../../rust/rust_holy/cargo/reference/manifest.html"><strong aria-hidden="true">4.1.5.3.3.</strong> Cargo.toml 清单详解</a></li><li class="chapter-item "><a href="../../rust/rust_holy/cargo/reference/cargo-target.html"><strong aria-hidden="true">4.1.5.3.4.</strong> Cargo Target</a></li><li class="chapter-item "><a href="../../rust/rust_holy/cargo/reference/workspaces.html"><strong aria-hidden="true">4.1.5.3.5.</strong> 工作空间 Workspace</a></li><li class="chapter-item "><a href="../../rust/rust_holy/cargo/reference/features/intro.html"><strong aria-hidden="true">4.1.5.3.6.</strong> 条件编译 Features</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../rust/rust_holy/cargo/reference/features/examples.html"><strong aria-hidden="true">4.1.5.3.6.1.</strong> Features 示例</a></li></ol></li><li class="chapter-item "><a href="../../rust/rust_holy/cargo/reference/profiles.html"><strong aria-hidden="true">4.1.5.3.7.</strong> 发布配置 Profile</a></li><li class="chapter-item "><a href="../../rust/rust_holy/cargo/reference/configuration.html"><strong aria-hidden="true">4.1.5.3.8.</strong> 通过 config.toml 对 Cargo 进行配置</a></li><li class="chapter-item "><a href="../../rust/rust_holy/cargo/reference/publishing-on-crates.io.html"><strong aria-hidden="true">4.1.5.3.9.</strong> 发布到 crates.io</a></li><li class="chapter-item "><a href="../../rust/rust_holy/cargo/reference/build-script/intro.html"><strong aria-hidden="true">4.1.5.3.10.</strong> 构建脚本 build.rs</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../rust/rust_holy/cargo/reference/build-script/examples.html"><strong aria-hidden="true">4.1.5.3.10.1.</strong> 构建脚本示例</a></li></ol></li></ol></li></ol></li><li class="chapter-item "><a href="../../rust/rust_holy/logs/intro.html"><strong aria-hidden="true">4.1.6.</strong> 日志和监控</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../rust/rust_holy/logs/about-log.html"><strong aria-hidden="true">4.1.6.1.</strong> 日志详解</a></li><li class="chapter-item "><a href="../../rust/rust_holy/logs/log.html"><strong aria-hidden="true">4.1.6.2.</strong> 日志门面 log</a></li><li class="chapter-item "><a href="../../rust/rust_holy/logs/tracing.html"><strong aria-hidden="true">4.1.6.3.</strong> 使用 tracing 记录日志</a></li><li class="chapter-item "><a href="../../rust/rust_holy/logs/tracing-logger.html"><strong aria-hidden="true">4.1.6.4.</strong> 自定义 tracing 的输出格式</a></li><li class="chapter-item "><a href="../../rust/rust_holy/logs/observe/intro.html"><strong aria-hidden="true">4.1.6.5.</strong> 监控</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../rust/rust_holy/logs/observe/about-observe.html"><strong aria-hidden="true">4.1.6.5.1.</strong> 可观测性</a></li><li class="chapter-item "><a href="../../rust/rust_holy/logs/observe/trace.html"><strong aria-hidden="true">4.1.6.5.2.</strong> 分布式追踪</a></li></ol></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">4.1.7.</strong> Appendix</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../rust/rust_holy/appendix/keywords.html"><strong aria-hidden="true">4.1.7.1.</strong> 关键字</a></li><li class="chapter-item "><a href="../../rust/rust_holy/appendix/operators.html"><strong aria-hidden="true">4.1.7.2.</strong> 运算符与符号</a></li><li class="chapter-item "><a href="../../rust/rust_holy/appendix/expressions.html"><strong aria-hidden="true">4.1.7.3.</strong> 表达式</a></li><li class="chapter-item "><a href="../../rust/rust_holy/appendix/derive.html"><strong aria-hidden="true">4.1.7.4.</strong> 派生特征 trait</a></li><li class="chapter-item "><a href="../../rust/rust_holy/appendix/prelude.html"><strong aria-hidden="true">4.1.7.5.</strong> prelude 模块 todo</a></li><li class="chapter-item "><a href="../../rust/rust_holy/appendix/rust-version.html"><strong aria-hidden="true">4.1.7.6.</strong> Rust 版本说明</a></li><li class="chapter-item "><a href="../../rust/rust_holy/appendix/rust-versions/intro.html"><strong aria-hidden="true">4.1.7.7.</strong> Rust 历次版本更新解读</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../appendix/rust-versions/1.58.html"><strong aria-hidden="true">4.1.7.7.1.</strong> 1.58</a></li><li class="chapter-item "><a href="../../appendix/rust-versions/1.59.html"><strong aria-hidden="true">4.1.7.7.2.</strong> 1.59</a></li><li class="chapter-item "><a href="../../appendix/rust-versions/1.60.html"><strong aria-hidden="true">4.1.7.7.3.</strong> 1.60</a></li><li class="chapter-item "><a href="../../appendix/rust-versions/1.61.html"><strong aria-hidden="true">4.1.7.7.4.</strong> 1.61</a></li><li class="chapter-item "><a href="../../appendix/rust-versions/1.62.html"><strong aria-hidden="true">4.1.7.7.5.</strong> 1.62</a></li><li class="chapter-item "><a href="../../appendix/rust-versions/1.63.html"><strong aria-hidden="true">4.1.7.7.6.</strong> 1.63</a></li><li class="chapter-item "><a href="../../appendix/rust-versions/1.64.html"><strong aria-hidden="true">4.1.7.7.7.</strong> 1.64</a></li><li class="chapter-item "><a href="../../appendix/rust-versions/1.65.html"><strong aria-hidden="true">4.1.7.7.8.</strong> 1.65</a></li><li class="chapter-item "><a href="../../appendix/rust-versions/1.66.html"><strong aria-hidden="true">4.1.7.7.9.</strong> 1.66</a></li><li class="chapter-item "><a href="../../appendix/rust-versions/1.67.html"><strong aria-hidden="true">4.1.7.7.10.</strong> 1.67</a></li></ol></li></ol></li></ol></li><li class="chapter-item "><a href="../../rust/pyo3/pyo3.html"><strong aria-hidden="true">4.2.</strong> PyO3</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../rust/pyo3/pythonmodules.html"><strong aria-hidden="true">4.2.1.</strong> Python 模组</a></li><li class="chapter-item "><a href="../../rust/pyo3/pythonfunctions/pre.html"><strong aria-hidden="true">4.2.2.</strong> Python 函数</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../rust/pyo3/pythonfunctions/function_signatures.html"><strong aria-hidden="true">4.2.2.1.</strong> 函数签名 Function signatures</a></li><li class="chapter-item "><a href="../../rust/pyo3/pythonfunctions/error_handling.html"><strong aria-hidden="true">4.2.2.2.</strong> 错误处理 Error handling</a></li></ol></li><li class="chapter-item "><a href="../../rust/pyo3/python_classes/pre.html"><strong aria-hidden="true">4.2.3.</strong> Python 类</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../rust/pyo3/python_classes/class_customization.html"><strong aria-hidden="true">4.2.3.1.</strong> 类的自定义</a></li><li class="chapter-item "><a href="../../rust/pyo3/python_classes/basic_type.html"><strong aria-hidden="true">4.2.3.2.</strong> 基本对象的自定义</a></li><li class="chapter-item "><a href="../../rust/pyo3/python_classes/emulate_number_type.html"><strong aria-hidden="true">4.2.3.3.</strong> 模拟数值类型</a></li><li class="chapter-item "><a href="../../rust/pyo3/python_classes/emulate_callable_objects.html"><strong aria-hidden="true">4.2.3.4.</strong> 模拟可调用类型</a></li></ol></li><li class="chapter-item "><a href="../../rust/pyo3/type_conversion/pre.html"><strong aria-hidden="true">4.2.4.</strong> 类型转换</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../rust/pyo3/type_conversion/tables.html"><strong aria-hidden="true">4.2.4.1.</strong> 将Rust类型映射为python类型</a></li><li class="chapter-item "><a href="../../rust/pyo3/type_conversion/traits.html"><strong aria-hidden="true">4.2.4.2.</strong> 转换特征 Conversion traits</a></li></ol></li><li class="chapter-item "><a href="../../rust/pyo3/python_exceptions.html"><strong aria-hidden="true">4.2.5.</strong> Python异常</a></li><li class="chapter-item "><a href="../../rust/pyo3/python_from_rust.html"><strong aria-hidden="true">4.2.6.</strong> 在Rust中调用Python</a></li><li class="chapter-item "><a href="../../rust/pyo3/GIL.html"><strong aria-hidden="true">4.2.7.</strong> GIL, 可变性与对象类型</a></li><li class="chapter-item "><a href="../../rust/pyo3/parallelism.html"><strong aria-hidden="true">4.2.8.</strong> 并行</a></li><li class="chapter-item "><a href="../../rust/pyo3/debugging.html"><strong aria-hidden="true">4.2.9.</strong> debug</a></li><li class="chapter-item "><a href="../../rust/pyo3/features_reference.html"><strong aria-hidden="true">4.2.10.</strong> 特性引用Features reference</a></li><li class="chapter-item "><a href="../../rust/pyo3/memory_management.html"><strong aria-hidden="true">4.2.11.</strong> 内存管理</a></li><li class="chapter-item "><a href="../../rust/pyo3/advanced_topic.html"><strong aria-hidden="true">4.2.12.</strong> 高阶话题</a></li><li class="chapter-item "><a href="../../rust/pyo3/building_distribution.md/pre.html"><strong aria-hidden="true">4.2.13.</strong> 构建与发布</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../rust/pyo3/building_distribution.md/multiple_version.html"><strong aria-hidden="true">4.2.13.1.</strong> 支持多个Python版本</a></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">4.2.14.</strong> 有用的包</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../rust/pyo3/useful_crates/logging.html"><strong aria-hidden="true">4.2.14.1.</strong> Logging</a></li><li class="chapter-item "><a href="../../rust/pyo3/useful_crates/async_and_await.html"><strong aria-hidden="true">4.2.14.2.</strong> async与await</a></li></ol></li></ol></li></ol></li><li class="chapter-item "><a href="../../others/pre.html"><strong aria-hidden="true">5.</strong> Others</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../others/com.html"><strong aria-hidden="true">5.1.</strong> COM组件</a></li><li class="chapter-item "><a href="../../others/cython/pre.html"><strong aria-hidden="true">5.2.</strong> cython</a></li></ol></li><li class="chapter-item "><a href="../../ml/ml.html"><strong aria-hidden="true">6.</strong> ML</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../ml/pre/pre.html"><strong aria-hidden="true">6.1.</strong> 绪言</a></li><li class="chapter-item "><a href="../../ml/chapter2/chapter2.html"><strong aria-hidden="true">6.2.</strong> 模型的评估与选择</a></li><li class="chapter-item "><a href="../../ml/chapter3/chapter3.html"><strong aria-hidden="true">6.3.</strong> 线性模型</a></li><li class="chapter-item "><a href="../../ml/chapter4/chapter4.html"><strong aria-hidden="true">6.4.</strong> 决策树</a></li><li class="chapter-item "><a href="../../ml/chapter5/chapter5.html"><strong aria-hidden="true">6.5.</strong> 神经网络</a></li><li class="chapter-item "><a href="../../ml/chapter6/chapter6.html"><strong aria-hidden="true">6.6.</strong> 支持向量机</a></li><li class="chapter-item "><a href="../../ml/chapter7/chapter7.html"><strong aria-hidden="true">6.7.</strong> 贝叶斯分类器</a></li><li class="chapter-item "><a href="../../ml/chapter8/chapter8.html"><strong aria-hidden="true">6.8.</strong> EM算法</a></li><li class="chapter-item "><a href="../../ml/chapter9/chapter9.html"><strong aria-hidden="true">6.9.</strong> 集成学习</a></li><li class="chapter-item "><a href="../../ml/chapter10/chapter10.html"><strong aria-hidden="true">6.10.</strong> 聚类算法</a></li><li class="chapter-item "><a href="../../ml/chapter11/chapter11.html"><strong aria-hidden="true">6.11.</strong> 降维与度量学习</a></li><li class="chapter-item "><a href="../../ml/chapter12/chapter12.html"><strong aria-hidden="true">6.12.</strong> 特征选择与稀疏学习</a></li><li class="chapter-item "><a href="../../ml/chapter13/chapter13.html"><strong aria-hidden="true">6.13.</strong> 计算学习理论</a></li><li class="chapter-item "><a href="../../ml/chapter14/chapter14.html"><strong aria-hidden="true">6.14.</strong> 半监督学习</a></li><li class="chapter-item "><a href="../../ml/chapter15/chapter15.html"><strong aria-hidden="true">6.15.</strong> 概率图模型</a></li><li class="chapter-item "><a href="../../ml/chapter16/chapter16.html"><strong aria-hidden="true">6.16.</strong> 强化学习</a></li></ol></li><li class="chapter-item "><a href="../../nn/basic.html"><strong aria-hidden="true">7.</strong> NN</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../nn/feedforward.html"><strong aria-hidden="true">7.1.</strong> 前馈神经网络</a></li><li class="chapter-item "><a href="../../nn/memory.html"><strong aria-hidden="true">7.2.</strong> 循环神经网络</a></li><li class="chapter-item "><a href="../../nn/GAN.html"><strong aria-hidden="true">7.3.</strong> 生成对抗网络</a></li><li class="chapter-item "><a href="../../nn/graph.html"><strong aria-hidden="true">7.4.</strong> 图神经网络</a></li></ol></li><li class="chapter-item "><a href="../../DRL/DRL.html"><strong aria-hidden="true">8.</strong> DRL</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../DRL/RL.html"><strong aria-hidden="true">8.1.</strong> RL</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../DRL/RL/chapter1/chapter1.html"><strong aria-hidden="true">8.1.1.</strong> 有模型数值迭代</a></li><li class="chapter-item "><a href="../../DRL/RL/chapter2/chapter2.html"><strong aria-hidden="true">8.1.2.</strong> 回合更新价值迭代</a></li><li class="chapter-item "><a href="../../DRL/RL/chapter3/chapter3.html"><strong aria-hidden="true">8.1.3.</strong> 时序差分价值迭代</a></li><li class="chapter-item "><a href="../../DRL/RL/chapter4/chapter4.html"><strong aria-hidden="true">8.1.4.</strong> 函数近似方法</a></li><li class="chapter-item "><a href="../../DRL/RL/chapter5/chapter5.html"><strong aria-hidden="true">8.1.5.</strong> 回合更新策略梯度方法</a></li><li class="chapter-item "><a href="../../DRL/RL/chapter6/chapter6.html"><strong aria-hidden="true">8.1.6.</strong> 执行者/评论者方法</a></li><li class="chapter-item "><a href="../../DRL/RL/chapter7/chapter7.html"><strong aria-hidden="true">8.1.7.</strong> 连续动作空间的确定性策略</a></li></ol></li><li class="chapter-item "><a href="../../DRL/fin.html"><strong aria-hidden="true">8.2.</strong> FIN</a></li><li class="chapter-item "><a href="../../DRL/DRL.html"><strong aria-hidden="true">8.3.</strong> DRL</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../DRL/DRL/chatgpt.html"><strong aria-hidden="true">8.3.1.</strong> ChatGPT历史</a></li></ol></li></ol></li><li class="chapter-item "><a href="../../option/option.html"><strong aria-hidden="true">9.</strong> Option</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../option/basic/pre.html"><strong aria-hidden="true">9.1.</strong> 期权基础概念</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../option/basic/basic.html"><strong aria-hidden="true">9.1.1.</strong> 基础知识</a></li><li class="chapter-item "><a href="../../option/basic/spread.html"><strong aria-hidden="true">9.1.2.</strong> 价差</a></li><li class="chapter-item "><a href="../../option/basic/theorems.html"><strong aria-hidden="true">9.1.3.</strong> 深入希腊值</a></li><li class="chapter-item "><a href="../../option/basic/trading.html"><strong aria-hidden="true">9.1.4.</strong> 日内交易要点</a></li></ol></li><li class="chapter-item "><a href="../../option/models/pre.html"><strong aria-hidden="true">9.2.</strong> 期权模型</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../option/models/sv.html"><strong aria-hidden="true">9.2.1.</strong> 经典SV</a></li><li class="chapter-item "><a href="../../option/models/rough.html"><strong aria-hidden="true">9.2.2.</strong> RV</a></li><li class="chapter-item "><a href="../../option/models/wing_model.html"><strong aria-hidden="true">9.2.3.</strong> wing_model</a></li></ol></li><li class="chapter-item "><a href="../../option/automatic_trading/automatic_trading_pre.html"><strong aria-hidden="true">9.3.</strong> Automatic_Trading</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../option/automatic_trading/automatic_hedging/automatic_hedging_pre.html"><strong aria-hidden="true">9.3.1.</strong> Automatic_Hedging</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../option/automatic_trading/automatic_hedging/hedging_vanilla.html"><strong aria-hidden="true">9.3.1.1.</strong> hedging_vanilla</a></li></ol></li></ol></li></ol></li><li class="chapter-item "><a href="../../philosophy/philosophy.html"><strong aria-hidden="true">10.</strong> Phylosophy</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../philosophy/history/history.html"><strong aria-hidden="true">10.1.</strong> 西方哲学史</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../philosophy/history/chapter1.html"><strong aria-hidden="true">10.1.1.</strong> 古希腊哲学</a></li><li class="chapter-item "><a href="../../philosophy/history/chapter2.html"><strong aria-hidden="true">10.1.2.</strong> 希腊化时期和中世纪的哲学</a></li><li class="chapter-item "><a href="../../philosophy/history/chapter3.html"><strong aria-hidden="true">10.1.3.</strong> 近代早期的哲学</a></li><li class="chapter-item "><a href="../../philosophy/history/chapter4.html"><strong aria-hidden="true">10.1.4.</strong> 近代晚期和19世纪哲学</a></li><li class="chapter-item "><a href="../../philosophy/history/chapter5.html"><strong aria-hidden="true">10.1.5.</strong> 20世纪和当代哲学</a></li></ol></li><li class="chapter-item "><a href="../../philosophy/critique_of_pure_reason/main.html"><strong aria-hidden="true">10.2.</strong> 纯粹理性批判</a></li></ol></li></ol>
        </div>
        <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
    </nav>

    <div id="page-wrapper" class="page-wrapper">

        <div class="page">
                        <div id="menu-bar-hover-placeholder"></div>
            <div id="menu-bar" class="menu-bar sticky bordered">
                <div class="left-buttons">
                    <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents"
                        aria-label="Toggle Table of Contents" aria-controls="sidebar">
                        <i class="fa fa-bars"></i>
                    </button>
                    <button id="theme-toggle" class="icon-button" type="button" title="Change theme"
                        aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                        <i class="fa fa-paint-brush"></i>
                    </button>
                    <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                        <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                        <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                        <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                        <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                        <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu (default)</button>
                        </li>
                    </ul>
                    <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)"
                        aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S"
                        aria-controls="searchbar">
                        <i class="fa fa-search"></i>
                    </button>
                </div>

                <h1 class="menu-title">布武不舞</h1>

                <div class="right-buttons">
                    <a href="../../print.html" title="Print this book" aria-label="Print this book">
                        <i id="print-button" class="fa fa-print"></i>
                    </a>

                </div>
            </div>

            <div id="search-wrapper" class="hidden">
                <form id="searchbar-outer" class="searchbar-outer">
                    <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..."
                        aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                </form>
                <div id="searchresults-outer" class="searchresults-outer hidden">
                    <div id="searchresults-header" class="searchresults-header"></div>
                    <ul id="searchresults">
                    </ul>
                </div>
            </div>

            <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
            <script type="text/javascript">
                document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');

                // Get viewed page store
                var viewed_key = 'mdbook-viewed';
                var viewed_map = {};
                try {
                    var viewed_storage = localStorage.getItem(viewed_key);
                    if (viewed_storage) {
                        viewed_map = JSON.parse(viewed_storage)
                    }
                } catch (e) { }

                Array.from(document.querySelectorAll('#sidebar a')).forEach(function (link) {
                    link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);

                    // Apply viewed style
                    if (viewed_map[link.pathname]) {
                        link.classList.add('md-viewed')
                    }
                });

                // Mark viewed after 30s
                setTimeout(function () {
                    viewed_map[location.pathname] = 1;
                    localStorage.setItem(viewed_key, JSON.stringify(viewed_map));
                }, 30000)
            </script>

            <div id="content" class="content">
                <!-- Page table of contents -->
                <div class="sidetoc">
                    <nav class="pagetoc"></nav>
                </div>
                <main>
                    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="htmlcss基础"><a class="header" href="#htmlcss基础">HTML&amp;CSS基础</a></h1>
<p>本章极简地涵盖了html与CSS的基础知识, 内容来自<a href="https://www.runoob.com/html/html-intro.html">html菜鸟教程</a>.</p>
<h2 id="一-html简介"><a class="header" href="#一-html简介">一. HTML简介</a></h2>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;h1&gt;我的第一个标题&lt;/h1&gt;

&lt;p&gt;我的第一个段落.&lt;/p&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ul>
<li><strong><code>&lt;!DOCTYPE html&gt;</code></strong> 声明为 HTML5 文档</li>
<li><strong><code>&lt;html&gt;</code></strong> 元素是 HTML 页面的根元素</li>
<li><strong><code>&lt;head&gt;</code></strong> 元素包含了文档的元（meta）数据,如 <meta charset="utf-8"> 定义网页编码格式为 utf-8.</li>
<li><strong><code>&lt;title&gt;</code></strong> 元素描述了文档的标题</li>
<li><strong><code>&lt;body&gt;</code></strong> 元素包含了可见的页面内容</li>
<li><strong><code>&lt;h1&gt;</code></strong> 元素定义一个大标题</li>
<li><strong><code>&lt;p&gt;</code></strong> 元素定义一个段落
<strong>注</strong>：在浏览器的页面上使用键盘上的 F12 按键开启调试模式,就可以看到组成标签</li>
</ul>
<h3 id="什么是html"><a class="header" href="#什么是html">什么是HTML</a></h3>
<p>HTML 是用来描述网页的一种语言.</p>
<ul>
<li>HTML 指的是超文本标记语言: <strong>H</strong>yper<strong>T</strong>ext <strong>M</strong>arkup <strong>L</strong>anguage</li>
<li>HTML 不是一种编程语言,而是一种<strong>标记</strong>语言</li>
<li>标记语言是一套<strong>标记标签</strong> (markup tag)</li>
<li>HTML 使用标记标签来<strong>描述</strong>网页</li>
<li>HTML 文档包含了HTML <strong>标签</strong>及<strong>文本</strong>内容</li>
<li>HTML文档也叫做 <strong>web 页面</strong></li>
</ul>
<h3 id="html标签"><a class="header" href="#html标签">HTML标签</a></h3>
<p>HTML 标记标签通常被称为 HTML 标签 (HTML tag).</p>
<ul>
<li>HTML 标签是由尖括号包围的关键词,比如 <html></li>
<li>HTML 标签通常是成对出现的,比如 <b> 和 </b></li>
<li>标签对中的第一个标签是开始标签,第二个标签是结束标签</li>
<li>开始和结束标签也被称为开放标签和闭合标签</li>
</ul>
<h3 id="html元素"><a class="header" href="#html元素">HTML元素</a></h3>
<p>&quot;HTML 标签&quot; 和 &quot;HTML 元素&quot; 通常都是描述同样的意思.
但是严格来讲, 一个 HTML 元素包含了开始标签与结束标签,如下实例:</p>
<p>HTML 元素:
<code>&lt;p&gt;</code>这是一个段落.<code>&lt;/p&gt;</code></p>
<h3 id="doctype-声明"><a class="header" href="#doctype-声明">&lt;!DOCTYPE&gt; 声明</a></h3>
<!DOCTYPE>声明有助于浏览器中正确显示网页.
<p>网络上有很多不同的文件,如果能够正确声明HTML的版本,浏览器就能正确显示网页内容.
doctype 声明是不区分大小写的,以下方式均可：</p>
<pre><code class="language-HTML">&lt;!DOCTYPE html&gt;

&lt;!DOCTYPE HTML&gt;

&lt;!doctype html&gt;

&lt;!Doctype Html&gt;
</code></pre>
<h4 id="通用声明"><a class="header" href="#通用声明">通用声明</a></h4>
<p><strong>HTML5</strong></p>
<pre><code class="language-HTML">&lt;!DOCTYPE html&gt;
</code></pre>
<p><strong>HTML 4.01</strong></p>
<pre><code class="language-HTML">&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;
&quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;
</code></pre>
<p><strong>XHTML 1.0</strong></p>
<pre><code class="language-HTML">&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot;
&quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;
</code></pre>
<h4 id="中文编码"><a class="header" href="#中文编码">中文编码</a></h4>
<p>目前在大部分浏览器中,直接输出中文会出现中文乱码的情况,这时候我们就需要在头部将字符声明为 UTF-8 或 GBK.</p>
<pre><code class="language-HTML">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset=&quot;UTF-8&quot;&gt;
&lt;title&gt;
页面标题&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;h1&gt;我的第一个标题&lt;/h1&gt;

&lt;p&gt;我的第一个段落.&lt;/p&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h2 id="二-html-属性"><a class="header" href="#二-html-属性">二. HTML 属性</a></h2>
<ul>
<li>HTML 元素可以设置属性</li>
<li>属性可以在元素中添加附加信息</li>
<li>属性一般描述于开始标签</li>
<li>属性总是以名称/值对的形式出现,比如：name=&quot;value&quot;.</li>
</ul>
<h3 id="属性实例"><a class="header" href="#属性实例">属性实例</a></h3>
<p>HTML 链接由 <code>&lt;a&gt;</code> 标签定义.链接的地址在 href 属性中指定：</p>
<pre><code class="language-HTML">&lt;a href=&quot;http://www.runoob.com&quot;&gt;这是一个链接&lt;/a&gt;
</code></pre>
<h3 id="html-属性常用引用属性值"><a class="header" href="#html-属性常用引用属性值">HTML 属性常用引用属性值</a></h3>
<p>属性值应该始终被包括在引号内.双引号是最常用的,不过使用单引号也没有问题.</p>
<p><strong>提示</strong>: 在某些个别的情况下,比如属性值本身就含有双引号,那么您必须使用单引号,例如：
<code>name='John &quot;ShotGun&quot; Nelson'</code></p>
<h3 id="html-属性参考手册"><a class="header" href="#html-属性参考手册">HTML 属性参考手册</a></h3>
<p>查看完整的HTML属性列表: <a href="https://www.runoob.com/tags/html-reference.html">HTML 标签参考手册</a>.</p>
<p>下面列出了适用于大多数 HTML 元素的属性：</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">属性</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: left">class</td><td style="text-align: left">为html元素定义一个或多个类名（classname）(类名从样式文件引入)</td></tr>
<tr><td style="text-align: left">id</td><td style="text-align: left">定义元素的唯一id</td></tr>
<tr><td style="text-align: left">style</td><td style="text-align: left">规定元素的行内样式（inline style）</td></tr>
<tr><td style="text-align: left">title</td><td style="text-align: left">描述了元素的额外信息 (作为工具条使用)</td></tr>
</tbody></table>
</div>
<h2 id="三-html元素"><a class="header" href="#三-html元素">三. HTML元素</a></h2>
<h3 id="html-head-元素"><a class="header" href="#html-head-元素">HTML <code>&lt;head&gt;</code> 元素</a></h3>
<p><code>&lt;head&gt;</code> 元素包含了所有的头部标签元素.在 <code>&lt;head&gt;</code>元素中你可以插入脚本（scripts）, 样式文件（CSS）,及各种meta信息.</p>
<p>可以添加在头部区域的元素标签为: <code>&lt;title&gt;, &lt;style&gt;, &lt;meta&gt;, &lt;link&gt;, &lt;script&gt;, &lt;noscript&gt; 和 &lt;base&gt;</code>.</p>
<h3 id="html-title-元素"><a class="header" href="#html-title-元素">HTML <code>&lt;title&gt;</code> 元素</a></h3>
<p><code>&lt;title&gt;</code> 标签定义了不同文档的标题.
<code>&lt;title&gt;</code> 在 HTML/XHTML 文档中是必需的.
<code>&lt;title&gt;</code> 元素:</p>
<ul>
<li>定义了浏览器工具栏的标题</li>
<li>当网页添加到收藏夹时,显示在收藏夹中的标题</li>
<li>显示在搜索引擎结果页面的标题</li>
</ul>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;文档标题&lt;/title&gt;
&lt;/head&gt;

&lt;body&gt;
文档内容......
&lt;/body&gt;

&lt;/html&gt;
</code></pre>
<h3 id="html-base-元素"><a class="header" href="#html-base-元素">HTML <code>&lt;base&gt;</code> 元素</a></h3>
<p><code>&lt;base&gt;</code> 标签描述了基本的链接地址/链接目标,该标签作为HTML文档中所有的链接标签的默认链接:</p>
<pre><code class="language-HTML">&lt;head&gt;
&lt;base href=&quot;http://www.runoob.com/images/&quot; target=&quot;_blank&quot;&gt;
&lt;/head&gt;
</code></pre>
<h3 id="html-link-元素"><a class="header" href="#html-link-元素">HTML <code>&lt;link&gt;</code> 元素</a></h3>
<link> 标签定义了文档与外部资源之间的关系.
<link> 标签通常用于链接到样式表:
<pre><code class="language-HTML">&lt;head&gt;
&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;mystyle.css&quot;&gt;
&lt;/head&gt;
</code></pre>
<h3 id="html-style-元素"><a class="header" href="#html-style-元素">HTML <code>&lt;style&gt;</code> 元素</a></h3>
<p><code>&lt;style&gt;</code> 标签定义了HTML文档的样式文件引用地址.
在<code>&lt;style&gt;</code> 元素中你也可以直接添加样式来渲染 HTML 文档:</p>
<pre><code class="language-HTML">&lt;head&gt;
&lt;style type=&quot;text/css&quot;&gt;
body {
    background-color:yellow;
}
p {
    color:blue
}
&lt;/style&gt;
&lt;/head&gt;
</code></pre>
<h3 id="html-meta-元素"><a class="header" href="#html-meta-元素">HTML <code>&lt;meta&gt;</code> 元素</a></h3>
<p>meta标签描述了一些基本的元数据.
<code>&lt;meta&gt;</code> 标签提供了元数据.元数据也不显示在页面上,但会被浏览器解析.
META 元素通常用于指定网页的描述,关键词,文件的最后修改时间,作者,和其他元数据.
元数据可以使用于浏览器（如何显示内容或重新加载页面）,搜索引擎（关键词）,或其他Web服务.
<code>&lt;meta&gt;</code> 一般放置于 <code>&lt;head&gt;</code> 区域</p>
<h3 id="meta-标签--使用实例"><a class="header" href="#meta-标签--使用实例"><code>&lt;meta&gt;</code> 标签- 使用实例</a></h3>
<p>为搜索引擎定义关键词:</p>
<pre><code class="language-HTML">&lt;meta name=&quot;keywords&quot; content=&quot;HTML, CSS, XML, XHTML, JavaScript&quot;&gt;
</code></pre>
<p>为网页定义描述内容:</p>
<pre><code class="language-HTML">&lt;meta name=&quot;description&quot; content=&quot;免费 Web &amp; 编程 教程&quot;&gt;
</code></pre>
<p>定义网页作者:</p>
<pre><code class="language-HTML">&lt;meta name=&quot;author&quot; content=&quot;Runoob&quot;&gt;
</code></pre>
<p>每30秒钟刷新当前页面:</p>
<pre><code class="language-HTML">&lt;meta http-equiv=&quot;refresh&quot; content=&quot;30&quot;&gt;
</code></pre>
<h3 id="html-script-元素"><a class="header" href="#html-script-元素">HTML <code>&lt;script&gt;</code> 元素</a></h3>
<p><code>&lt;script&gt;</code>标签用于加载脚本文件,如： JavaScript.
<code>&lt;script&gt;</code>元素在以后的章节中会详细描述.</p>
<h3 id="html-head-元素-1"><a class="header" href="#html-head-元素-1">HTML head 元素</a></h3>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">标签</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>&lt;head&gt;</code></td><td style="text-align: left">定义了文档的信息</td></tr>
<tr><td style="text-align: left"><code>&lt;title&gt;</code></td><td style="text-align: left">定义了文档的标题</td></tr>
<tr><td style="text-align: left"><code>&lt;base&gt;</code></td><td style="text-align: left">定义了页面链接标签的默认链接地址</td></tr>
<tr><td style="text-align: left"><code>&lt;link&gt;</code></td><td style="text-align: left">定义了一个文档和外部资源之间的关系</td></tr>
<tr><td style="text-align: left"><code>&lt;meta&gt;</code></td><td style="text-align: left">定义了HTML文档中的元数据</td></tr>
<tr><td style="text-align: left"><code>&lt;script&gt;</code></td><td style="text-align: left">定义了客户端的脚本文件</td></tr>
<tr><td style="text-align: left"><code>&lt;style&gt;</code></td><td style="text-align: left">定义了HTML文档的样式文件</td></tr>
</tbody></table>
</div>
<h2 id="四-html布局"><a class="header" href="#四-html布局">四. HTML布局</a></h2>
<h3 id="html-布局---使用div元素"><a class="header" href="#html-布局---使用div元素">HTML 布局 - 使用<code>&lt;div&gt;</code>元素</a></h3>
<p>div 元素是用于分组 HTML 元素的块级元素.
下面的例子使用五个 div 元素来创建多列布局：</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;div id=&quot;container&quot; style=&quot;width:500px&quot;&gt;

&lt;div id=&quot;header&quot; style=&quot;background-color:#FFA500;&quot;&gt;
&lt;h1 style=&quot;margin-bottom:0;&quot;&gt;主要的网页标题&lt;/h1&gt;&lt;/div&gt;

&lt;div id=&quot;menu&quot; style=&quot;background-color:#FFD700;height:200px;width:100px;float:left;&quot;&gt;
&lt;b&gt;菜单&lt;/b&gt;&lt;br&gt;
HTML&lt;br&gt;
CSS&lt;br&gt;
JavaScript&lt;/div&gt;

&lt;div id=&quot;content&quot; style=&quot;background-color:#EEEEEE;height:200px;width:400px;float:left;&quot;&gt;
内容在这里&lt;/div&gt;

&lt;div id=&quot;footer&quot; style=&quot;background-color:#FFA500;clear:both;text-align:center;&quot;&gt;
版权 © runoob.com&lt;/div&gt;

&lt;/div&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>上面的 HTML 代码会产生如下结果：</p>
<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>菜鸟教程(runoob.com)</title>
</head>
<body>
<div id="container" style="width:500px">
<div id="header" style="background-color:#FFA500;">
<h1 style="margin-bottom:0;">主要的网页标题</h1></div>
<div id="menu" style="background-color:#FFD700;height:200px;width:100px;float:left;">
<b>菜单</b><br>
HTML<br>
CSS<br>
JavaScript</div>
<div id="content" style="background-color:#EEEEEE;height:200px;width:400px;float:left;">
内容在这里</div>
<div id="footer" style="background-color:#FFA500;clear:both;text-align:center;">
版权 © runoob.com</div>
</div>
</body>
</html>
<h3 id="html-布局---使用表格"><a class="header" href="#html-布局---使用表格">HTML 布局 - 使用表格</a></h3>
<p>使用 HTML <code>&lt;table&gt;</code> 标签是创建布局的一种简单的方式.
大多数站点可以使用 <code>&lt;div&gt;</code> 或者 <code>&lt;table&gt;</code> 元素来创建多列.CSS 用于对元素进行定位,或者为页面创建背景以及色彩丰富的外观.
下面的例子使用三行两列的表格 - 第一和最后一行使用 colspan 属性来横跨两列：</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;table width=&quot;500&quot; border=&quot;0&quot;&gt;
&lt;tr&gt;
&lt;td colspan=&quot;2&quot; style=&quot;background-color:#FFA500;&quot;&gt;
&lt;h1&gt;主要的网页标题&lt;/h1&gt;
&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td style=&quot;background-color:#FFD700;width:100px;&quot;&gt;
&lt;b&gt;菜单&lt;/b&gt;&lt;br&gt;
HTML&lt;br&gt;
CSS&lt;br&gt;
JavaScript
&lt;/td&gt;
&lt;td style=&quot;background-color:#eeeeee;height:200px;width:400px;&quot;&gt;
内容在这里&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td colspan=&quot;2&quot; style=&quot;background-color:#FFA500;text-align:center;&quot;&gt;
版权 © runoob.com&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>菜鸟教程(runoob.com)</title>
</head>
<body>
<table width="500" border="0">
<tr>
<td colspan="2" style="background-color:#FFA500;">
<h1 id="主要的网页标题"><a class="header" href="#主要的网页标题">主要的网页标题</a></h1>
</td>
</tr>
<tr>
<td style="background-color:#FFD700;width:100px;">
<b>菜单</b><br>
HTML<br>
CSS<br>
JavaScript
</td>
<td style="background-color:#eeeeee;height:200px;width:400px;">
内容在这里</td>
</tr>
<tr>
<td colspan="2" style="background-color:#FFA500;text-align:center;">
版权 © runoob.com</td>
</tr>
</table>
</body>
</html>
<h3 id="html-布局---有用的提示"><a class="header" href="#html-布局---有用的提示">HTML 布局 - 有用的提示</a></h3>
<ul>
<li>Tip: 使用 CSS 最大的好处是,如果把 CSS 代码存放到外部样式表中,那么站点会更易于维护.通过编辑单一的文件,就可以改变所有页面的布局.如需学习更多有关 CSS 的知识,请访问我们的CSS 教程.</li>
<li>Tip: 由于创建高级的布局非常耗时,使用模板是一个快速的选项.通过搜索引擎可以找到很多免费的网站模板（您可以使用这些预先构建好的网站布局,并优化它们）.</li>
</ul>
<h2 id="五-html其他"><a class="header" href="#五-html其他">五. HTML其他</a></h2>
<h1 id="css基础"><a class="header" href="#css基础">CSS基础</a></h1>
<ul>
<li>CSS 指层叠样式表 (Cascading Style Sheets)</li>
<li>样式定义<strong>如何显示</strong> HTML 元素</li>
<li>样式通常存储在<strong>样式表</strong>中</li>
<li>把样式添加到 HTML 4.0 中，是为了<strong>解决内容与表现分离的问题</strong></li>
<li><strong>外部样式表</strong>可以极大提高工作效率</li>
<li>外部样式表通常存储在 <strong>CSS 文件</strong>中</li>
<li>多个样式定义可<strong>层叠</strong>为一个</li>
</ul>
<p>CSS 规则由两个主要的部分构成：<strong>选择器</strong>，以及<strong>一条或多条声明</strong>: <strong>选择器</strong>通常是您需要改变样式的 HTML 元素，每条声明由<strong>一个属性和一个值</strong>组成. 属性（property）是您希望设置的样式属性（style attribute）.每个属性有一个值. 属性和值被冒号分开.</p>
<p>CSS声明总是以分号<code>;</code>结束，声明总以大括号 <code>{}</code> 括起来, <strong>CSS注释</strong>以 <code>/*</code> 开始, 以 <code>*/</code> 结束</p>
<pre><code class="language-css">/*这是个注释*/
p
{
    color:red;
    /*这是另一个注释*/
    text-align:center;
}
</code></pre>
<h2 id="一-基本操作"><a class="header" href="#一-基本操作">一. 基本操作</a></h2>
<h3 id="id-和-class-选择器"><a class="header" href="#id-和-class-选择器">id 和 class 选择器</a></h3>
<p><strong>id 选择器</strong>可以为标有特定 id 的 HTML 元素指定特定的样式. HTML元素以id属性来设置id选择器,CSS 中 id 选择器以 &quot;#&quot; 来定义. 以下的样式规则应用于<strong>元素属性</strong> <code>id=&quot;para1&quot;</code>:</p>
<pre><code class="language-css">#para1
{
    text-align:center;
    color:red;
}
</code></pre>
<p><strong>class 选择器</strong>用于描述一组元素的样式，class 选择器有别于id选择器，class可以在多个元素中使用. class 选择器在 HTML 中以 class 属性表示, 在 CSS 中，<strong>类选择器以一个点 . 号</strong>显示：在以下的例子中，<strong>所有拥有 center 类的 HTML 元素</strong>均为居中.</p>
<pre><code class="language-css">.center {text-align:center;}
</code></pre>
<p>也可以指定特定的 HTML 元素使用 <code>class.</code> 在以下实例中, 所有的 <code>p</code> 元素使用 <code>class=&quot;center&quot;</code> 让该元素的文本居中:</p>
<pre><code class="language-css">p.center {text-align:center;}
</code></pre>
<h3 id="css创建"><a class="header" href="#css创建">CSS创建</a></h3>
<p>插入样式表的方法有三种:</p>
<ul>
<li><strong>外部样式表</strong>(External style sheet)</li>
<li><strong>内部样式表</strong>(Internal style sheet)</li>
<li><strong>内联样式</strong>(Inline style)</li>
</ul>
<h4 id="外部样式表"><a class="header" href="#外部样式表">外部样式表</a></h4>
<p>当样式需要应用于很多页面时，外部样式表将是理想的选择. 在使用外部样式表的情况下，可以通过改变一个文件来改变整个站点的外观. 每个页面使用 <code>\&lt;link\&gt;</code> 标签链接到样式表.  <code>\&lt;link\&gt;</code> 标签在（文档的）头部：</p>
<pre><code class="language-css">&lt;head&gt;
&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;mystyle.css&quot;&gt;
&lt;/head&gt;
</code></pre>
<p>浏览器会从文件 mystyle.css 中读到样式声明，并根据它来格式文档.</p>
<p>外部样式表可以在任何文本编辑器中进行编辑. 文件不能包含任何的 html 标签. 样式表应该以 .css 扩展名进行保存. 下面是一个样式表文件的例子：</p>
<pre><code class="language-css">hr {color:sienna;}
p {margin-left:20px;}
body {background-image:url(&quot;/images/back40.gif&quot;);}
</code></pre>
<h4 id="内部样式表"><a class="header" href="#内部样式表">内部样式表</a></h4>
<p>当单个文档需要特殊的样式时，就应该使用内部样式表. 你可以使用 <code>\&lt;style\&gt;</code> 标签在文档头部定义内部样式表，就像这样:</p>
<pre><code class="language-css">&lt;head&gt;
&lt;style&gt;
hr {color:sienna;}
p {margin-left:20px;}
body {background-image:url(&quot;images/back40.gif&quot;);}
&lt;/style&gt;
&lt;/head&gt;
</code></pre>
<h4 id="内联样式"><a class="header" href="#内联样式">内联样式</a></h4>
<p>由于要将表现和内容混杂在一起，内联样式会损失掉样式表的许多优势. 请慎用这种方法，例如当样式仅需要在一个元素上应用一次时.</p>
<p>要使用内联样式，你需要在相关的标签内使用样式（style）属性. Style 属性可以包含任何 CSS 属性. 本例展示如何改变段落的颜色和左外边距：</p>
<pre><code class="language-css">&lt;p style=&quot;color:sienna;margin-left:20px&quot;&gt;这是一个段落。&lt;/p&gt;
</code></pre>
<h4 id="多重样式"><a class="header" href="#多重样式">多重样式</a></h4>
<p>如果某些属性在不同的样式表中被同样的选择器定义，那么属性值将从更具体的样式表中被继承过来.</p>
<p>例如，外部样式表拥有针对 h3 选择器的三个属性：</p>
<pre><code class="language-css">h3
{
    color:red;
    text-align:left;
    font-size:8pt;
}
</code></pre>
<p>而内部样式表拥有针对 h3 选择器的两个属性：</p>
<pre><code class="language-css">h3
{
    text-align:right;
    font-size:20pt;
}
</code></pre>
<p>假如拥有内部样式表的这个页面同时与外部样式表链接，那么 h3 得到的样式是：</p>
<pre><code class="language-css">color:red;
text-align:right;
font-size:20pt;
</code></pre>
<p>即颜色属性将被继承于外部样式表，而文字排列（<code>text-alignment</code>）和字体尺寸（<code>font-size</code>）会被内部样式表中的规则取代.</p>
<h4 id="多重样式优先级"><a class="header" href="#多重样式优先级">多重样式优先级</a></h4>
<p>样式表允许以多种方式规定样式信息. 样式可以规定在单个的 HTML 元素中，在 HTML 页的头元素中，或在一个外部的 CSS 文件中. 甚至可以在同一个 HTML 文档内部引用多个外部样式表。</p>
<p>一般情况下，优先级如下：</p>
<blockquote>
<p>（内联样式）Inline style &gt; （内部样式）Internal style sheet &gt;（外部样式）External style sheet &gt; 浏览器默认样式</p>
</blockquote>
<pre><code class="language-css">&lt;head&gt;
    &lt;!-- 外部样式 style.css --&gt;
    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;style.css&quot;/&gt;
    &lt;!-- 设置：h3{color:blue;} --&gt;
    &lt;style type=&quot;text/css&quot;&gt;
      /* 内部样式 */
      h3{color:green;}
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h3&gt;显示绿色，是内部样式&lt;/h3&gt;
&lt;/body&gt;
</code></pre>
<p><strong>注意</strong>：如果外部样式放在内部样式的后面，则外部样式将覆盖内部样式，实例如下：</p>
<pre><code class="language-css">&lt;head&gt;
    &lt;!-- 设置：h3{color:blue;} --&gt;
    &lt;style type=&quot;text/css&quot;&gt;
      /* 内部样式 */
      h3{color:green;}
    &lt;/style&gt;
    &lt;!-- 外部样式 style.css --&gt;
    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;style.css&quot;/&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h3&gt;显示蓝色，是外部样式&lt;/h3&gt;
&lt;/body&gt;
</code></pre>
<h3 id="css背景"><a class="header" href="#css背景">CSS背景</a></h3>
<p>CSS 背景属性用于定义HTML元素的背景，CSS 属性定义背景效果:</p>
<ul>
<li><code>background-color</code></li>
<li><code>background-image</code></li>
<li><code>background-repeat</code></li>
<li><code>background-attachment</code></li>
<li><code>background-position</code></li>
</ul>
<h4 id="背景颜色"><a class="header" href="#背景颜色">背景颜色</a></h4>
<pre><code class="language-css">body {background-color:#b0c4de;}
</code></pre>
<p>CSS中，颜色值通常以以下方式定义:</p>
<ul>
<li>十六进制：&quot;#ff0000&quot;</li>
<li>RGB：&quot;rgb(255,0,0)&quot;</li>
<li>颜色名称：&quot;red&quot;</li>
</ul>
<h4 id="背景图像"><a class="header" href="#背景图像">背景图像</a></h4>
<p>默认情况下，背景图像进行平铺重复显示，以覆盖整个元素实体.</p>
<pre><code class="language-css">body {background-image:url('paper.gif');}
</code></pre>
<h4 id="背景图像---水平或垂直平铺"><a class="header" href="#背景图像---水平或垂直平铺">背景图像 - 水平或垂直平铺</a></h4>
<p>默认情况下 <code>background-image</code> 属性会在页面的水平或者垂直方向平铺. 一些图像如果在水平方向与垂直方向平铺，这样看起来很不协调，如下所示:</p>
<pre><code class="language-css">body
{
background-image:url('gradient2.png');
}
</code></pre>
<p>如果图像只在水平方向平铺 (<code>repeat-x</code>)</p>
<pre><code class="language-css">body
{
background-image:url('gradient2.png');
background-repeat:repeat-x;
}
</code></pre>
<h4 id="背景图像--设置定位与不平铺"><a class="header" href="#背景图像--设置定位与不平铺">背景图像- 设置定位与不平铺</a></h4>
<p>如果不想让图像平铺，可以使用 <code>background-repeat</code> 属性:</p>
<pre><code class="language-css">body
{
background-image:url('img_tree.png');
background-repeat:no-repeat;
}
</code></pre>
<p>以上实例中，背景图像与文本显示在同一个位置，为了让页面排版更加合理，不影响文本的阅读，我们可以改变图像的位置. 可以利用 <code>background-position</code> 属性改变图像在背景中的位置:</p>
<pre><code class="language-css">body
{
background-image:url('img_tree.png');
background-repeat:no-repeat;
background-position:right top;
}
</code></pre>
<h3 id="css文本格式"><a class="header" href="#css文本格式">CSS文本格式</a></h3>
<h4 id="文本颜色"><a class="header" href="#文本颜色">文本颜色</a></h4>
<pre><code class="language-css">body {color:red;}
h1 {color:#00ff00;}
h2 {color:rgb(255,0,0);}
</code></pre>
<h4 id="文本的对齐方式"><a class="header" href="#文本的对齐方式">文本的对齐方式</a></h4>
<p>文本可居中或对齐到左或右,两端对齐. 当<code>text-align</code>设置为<code>&quot;justify&quot;</code>，每一行被展开为宽度相等，左，右外边距是对齐(如杂志和报纸).</p>
<pre><code class="language-css">h1 {text-align:center;}
p.date {text-align:right;}
p.main {text-align:justify;}
</code></pre>
<h4 id="文本修饰"><a class="header" href="#文本修饰">文本修饰</a></h4>
<p><code>text-decoration</code> 属性用来设置或删除文本的装饰. 从设计的角度看 <code>text-decoration</code>属性<strong>主要是用来删除链接的下划线</strong>：</p>
<pre><code class="language-css">a {text-decoration:none;}

h1 {text-decoration:overline;}
h2 {text-decoration:line-through;}
h3 {text-decoration:underline;}
</code></pre>
<h4 id="文本转换"><a class="header" href="#文本转换">文本转换</a></h4>
<p>文本转换属性是用来指定在一个文本中的大写和小写字母. 可用于所有字句变成大写或小写字母，或每个单词的首字母大写.</p>
<pre><code class="language-css">p.uppercase {text-transform:uppercase;}
p.lowercase {text-transform:lowercase;}
p.capitalize {text-transform:capitalize;}
</code></pre>
<h4 id="文本缩进"><a class="header" href="#文本缩进">文本缩进</a></h4>
<p>文本缩进属性是用来指定文本的第一行的缩进。</p>
<pre><code class="language-css">p {text-indent:50px;}
</code></pre>
<h3 id="css字体"><a class="header" href="#css字体">CSS字体</a></h3>
<h4 id="css字型"><a class="header" href="#css字型">CSS字型</a></h4>
<p>在CSS中，有两种类型的字体系列名称：</p>
<ul>
<li><strong>通用字体系列</strong> - 拥有相似外观的字体系统组合（如 &quot;Serif&quot; 或 &quot;Monospace&quot;）</li>
<li><strong>特定字体系列</strong> - 一个特定的字体系列（如 &quot;Times&quot; 或 &quot;Courier&quot;）</li>
</ul>
<h4 id="字体系列"><a class="header" href="#字体系列">字体系列</a></h4>
<p><code>font-family</code> 属性设置文本的字体系列. <code>font-family</code> 属性应该设置几个字体名称作为一种&quot;后备&quot;机制，如果浏览器不支持第一种字体，他将尝试下一种字体.</p>
<p>多个字体系列是用一个逗号分隔指明：</p>
<pre><code class="language-css">p{font-family:&quot;Times New Roman&quot;, Times, serif;}
</code></pre>
<h4 id="字体样式"><a class="header" href="#字体样式">字体样式</a></h4>
<p>主要是用于指定斜体文字的字体样式属性. 这个属性有三个值：</p>
<ul>
<li>正常 - 正常显示文本</li>
<li>斜体 - 以斜体字显示的文字</li>
<li>倾斜的文字 - 文字向一边倾斜（和斜体非常类似，但不太支持）</li>
</ul>
<pre><code class="language-css">p.normal {font-style:normal;}
p.italic {font-style:italic;}
p.oblique {font-style:oblique;}
</code></pre>
<h4 id="字体大小"><a class="header" href="#字体大小">字体大小</a></h4>
<p><code>font-size</code> 属性设置文本的大小. 请务必使用正确的HTML标签，<code>\&lt;h1\&gt;</code> - <code>\&lt;h6\&gt;</code>表示标题和<code>\&lt;p\&gt;</code>表示段落：</p>
<p>字体大小的值可以是<strong>绝对或相对</strong>的大小</p>
<p><strong>绝对大小：</strong></p>
<ul>
<li>设置一个指定大小的文本</li>
<li>不允许用户在所有浏览器中改变文本大小</li>
<li>确定了输出的物理尺寸时绝对大小很有用</li>
</ul>
<p><strong>相对大小：</strong></p>
<ul>
<li>相对于周围的元素来设置大小</li>
<li>允许用户在浏览器中改变文字大小</li>
<li>Remark 如果你不指定一个字体的大小，默认大小和普通文本段落一样，是16像素（16px=1em）。</li>
</ul>
<h4 id="设置字体大小像素"><a class="header" href="#设置字体大小像素">设置字体大小像素</a></h4>
<p>设置文字的大小与像素，让您完全控制文字大小：</p>
<pre><code class="language-css">h1 {font-size:40px;}
h2 {font-size:30px;}
p {font-size:14px;}
</code></pre>
<h4 id="用em来设置字体大小"><a class="header" href="#用em来设置字体大小">用em来设置字体大小</a></h4>
<p>为了避免Internet Explorer 中无法调整文本的问题，许多开发者使用 <code>em</code> 单位代替像素. em的尺寸单位由W3C建议. 1em和当前字体大小相等. 在浏览器中默认的文字大小是16px. 因此，1em的默认大小是16px. 可以通过下面这个公式将像素转换为em：px/16=em</p>
<pre><code class="language-css">h1 {font-size:2.5em;} /* 40px/16=2.5em */
h2 {font-size:1.875em;} /* 30px/16=1.875em */
p {font-size:0.875em;} /* 14px/16=0.875em */
</code></pre>
<p>在上面的例子，em的文字大小是与前面的例子中像素一样. 不过，如果使用 em 单位，则可以在所有浏览器中调整文本大小.</p>
<h4 id="使用百分比和em组合"><a class="header" href="#使用百分比和em组合">使用百分比和EM组合</a></h4>
<p>在所有浏览器的解决方案中，设置 <body>元素的默认字体大小的是百分比：</p>
<pre><code class="language-css">body {font-size:100%;}
h1 {font-size:2.5em;}
h2 {font-size:1.875em;}
p {font-size:0.875em;}
</code></pre>
<h3 id="css链接"><a class="header" href="#css链接">CSS链接</a></h3>
<h4 id="链接样式"><a class="header" href="#链接样式">链接样式</a></h4>
<p>链接的样式，可以用任何CSS属性（如颜色，字体，背景等）.特别的链接，可以有不同的样式，这取决于他们是什么状态.</p>
<p>这四个链接状态是：</p>
<ul>
<li>a:link - 正常，未访问过的链接</li>
<li>a:visited - 用户已访问过的链接</li>
<li>a:hover - 当用户鼠标放在链接上时</li>
<li>a:active - 链接被点击的那一刻</li>
</ul>
<pre><code class="language-css">a:link {color:#000000;}      /* 未访问链接*/
a:visited {color:#00FF00;}  /* 已访问链接 */
a:hover {color:#FF00FF;}  /* 鼠标移动到链接上 */
a:active {color:#0000FF;}  /* 鼠标点击时 */
</code></pre>
<p>当设置为若干链路状态的样式，也有一些顺序规则：</p>
<ul>
<li>a:hover 必须跟在 a:link 和 a:visited后面</li>
<li>a:active 必须跟在 a:hover后面</li>
</ul>
<h4 id="常见的链接样式"><a class="header" href="#常见的链接样式">常见的链接样式</a></h4>
<p>根据上述链接的颜色变化的例子，看它是在什么状态.
让我们通过一些其他常见的方式转到链接样式：</p>
<h4 id="文本修饰-1"><a class="header" href="#文本修饰-1">文本修饰</a></h4>
<p><code>text-decoration</code> 属性主要用于删除链接中的下划线：</p>
<pre><code class="language-css">a:link {text-decoration:none;}
a:visited {text-decoration:none;}
a:hover {text-decoration:underline;}
a:active {text-decoration:underline;}
</code></pre>
<h4 id="背景颜色-1"><a class="header" href="#背景颜色-1">背景颜色</a></h4>
<p>背景颜色属性指定链接背景色：</p>
<pre><code class="language-css">a:link {background-color:#B2FF99;}
a:visited {background-color:#FFFF85;}
a:hover {background-color:#FF704D;}
a:active {background-color:#FF704D;}
</code></pre>
<h3 id="css列表"><a class="header" href="#css列表">CSS列表</a></h3>
<p>CSS 列表属性作用如下：</p>
<ul>
<li>设置不同的列表项标记为有序列表</li>
<li>设置不同的列表项标记为无序列表</li>
<li>设置列表项标记为图像</li>
</ul>
<h4 id="列表"><a class="header" href="#列表">列表</a></h4>
<p>在 HTML中，有两种类型的列表：</p>
<ul>
<li>无序列表 <code>ul</code> - 列表项标记用特殊图形（如小黑点、小方框等）</li>
<li>有序列表 <code>ol</code> - 列表项的标记有数字或字母</li>
<li></li>
</ul>
<p>使用 CSS，可以列出进一步的样式，并可用图像作列表项标记.</p>
<h4 id="不同的列表项标记"><a class="header" href="#不同的列表项标记">不同的列表项标记</a></h4>
<p>list-style-type属性指定列表项标记的类型是：</p>
<pre><code class="language-css">ul.a {list-style-type: circle;}
ul.b {list-style-type: square;}

ol.c {list-style-type: upper-roman;}
ol.d {list-style-type: lower-alpha;}
</code></pre>
<h4 id="作为列表项标记的图像"><a class="header" href="#作为列表项标记的图像">作为列表项标记的图像</a></h4>
<p>要指定列表项标记的图像，使用列表样式图像属性：</p>
<pre><code class="language-css">ul
{
    list-style-image: url('sqpurple.gif');
}
</code></pre>
<h3 id="css表格"><a class="header" href="#css表格">CSS表格</a></h3>
<h4 id="表格边框"><a class="header" href="#表格边框">表格边框</a></h4>
<p>指定CSS表格边框，使用<code>border</code>属性. 下面的例子指定了一个表格的<code>Th</code>和<code>TD</code>元素的黑色边框：</p>
<pre><code class="language-css">table, th, td
{
    border: 1px solid black;
}
</code></pre>
<p>请注意，在上面的例子中的表格有双边框. 这是因为表和<code>th/ td</code>元素有独立的边界. 为了显示一个表的单个边框，使用 <code>border-collapse</code>属性.</p>
<h4 id="折叠边框"><a class="header" href="#折叠边框">折叠边框</a></h4>
<p><code>border-collapse</code> 属性设置表格的边框是否被折叠成一个单一的边框或隔开：</p>
<pre><code class="language-css">table
{
    border-collapse:collapse;
}
table, th, td
{
    border: 1px solid black;
}
</code></pre>
<h4 id="表格宽度和高度"><a class="header" href="#表格宽度和高度">表格宽度和高度</a></h4>
<p><code>Width</code>和<code>height</code>属性定义表格的宽度和高度.
下面的例子是设置100％的宽度，50像素的th元素的高度的表格：</p>
<pre><code class="language-css">table
{
    width:100%;
}
th
{
    height:50px;
}
</code></pre>
<h4 id="表格文字对齐"><a class="header" href="#表格文字对齐">表格文字对齐</a></h4>
<p>表格中的文本对齐和垂直对齐属性. `text-align 属性设置水平对齐方式，向左，右，或中心：</p>
<pre><code class="language-css">td
{
    text-align:right;
}
</code></pre>
<p>垂直对齐属性设置垂直对齐，比如顶部，底部或中间：</p>
<pre><code class="language-css">td
{
    height:50px;
    vertical-align:bottom;
}
</code></pre>
<h4 id="表格填充"><a class="header" href="#表格填充">表格填充</a></h4>
<p>如需控制边框和表格内容之间的间距，应使用<code>td</code>和<code>th</code>元素的填充属性：</p>
<pre><code class="language-css">td
{
    padding:15px;
}
</code></pre>
<h4 id="表格颜色"><a class="header" href="#表格颜色">表格颜色</a></h4>
<p>下面的例子指定边框的颜色，和th元素的文本和背景颜色：</p>
<pre><code class="language-css">table, td, th
{
    border:1px solid green;
}
th
{
    background-color:green;
    color:white;
}
</code></pre>
<h3 id="css-盒子模型box-model"><a class="header" href="#css-盒子模型box-model">CSS 盒子模型(Box Model)</a></h3>
<p>所有HTML元素可以看作盒子，在CSS中，&quot;box model&quot;这一术语是用来设计和布局时使用. CSS盒模型本质上是一个盒子，封装周围的HTML元素，它包括：边距，边框，填充，和实际内容. 盒模型允许我们在其它元素和周围元素边框之间的空间放置元素.</p>
<ul>
<li><strong>Margin(外边距)</strong> - 清除边框外的区域，外边距是透明的</li>
<li><strong>Border(边框)</strong> - 围绕在内边距和内容外的边框</li>
<li><strong>Padding(内边距)</strong> - 清除内容周围的区域，内边距是透明的</li>
<li><strong>Content(内容)</strong> - 盒子的内容，显示文本和图像</li>
</ul>
<h4 id="元素的宽度和高度"><a class="header" href="#元素的宽度和高度">元素的宽度和高度</a></h4>
<p><strong>重要:</strong> 当您指定一个 CSS 元素的宽度和高度属性时，你只是设置内容区域的宽度和高度. 要知道，完整大小的元素，你还必须添加内边距，边框和外边距.</p>
<pre><code class="language-css">div {
    width: 300px;
    border: 25px solid green;
    padding: 25px;
    margin: 25px;
}
</code></pre>
<p>300px (宽)
+ 50px (左 + 右填充)
+ 50px (左 + 右边框)
+ 50px (左 + 右边距)
= 450px</p>
<pre><code class="language-css">div {
    width: 220px;
    padding: 10px;
    border: 5px solid gray;
    margin: 0;
}
</code></pre>
<p>最终元素的总宽度计算公式是这样的：
总元素的宽度=宽度+左填充+右填充+左边框+右边框+左边距+右边距</p>
<p>元素的总高度最终计算公式是这样的：
总元素的高度=高度+顶部填充+底部填充+上边框+下边框+上边距+下边距</p>
<h3 id="css边框"><a class="header" href="#css边框">CSS边框</a></h3>
<h4 id="边框样式"><a class="header" href="#边框样式">边框样式</a></h4>
<h5 id="border-style值"><a class="header" href="#border-style值">border-style值</a></h5>
<ul>
<li><code>none</code>: 默认无边框</li>
<li><code>dotted</code>: 定义一个点线边框</li>
<li><code>dashed</code>: 定义一个虚线边框</li>
<li><code>solid</code>: 定义实线边框</li>
<li><code>double</code>: 定义两个边框，两个边框的宽度和 <code>border-width</code> 的值相同</li>
<li><code>groove</code>: 定义3d沟槽边框, 效果取决于边框的颜色值</li>
<li><code>ridge</code>: 定义3d脊边框, 效果取决于边框的颜色值</li>
<li><code>inset</code>:定义一个3D的嵌入边框, 效果取决于边框的颜色值</li>
<li><code>outset</code>: 定义一个3D突出边框, 效果取决于边框的颜色值</li>
</ul>
<h4 id="边框宽度"><a class="header" href="#边框宽度">边框宽度</a></h4>
<p>您可以通过 <code>border-width</code> 属性为边框指定宽度.</p>
<p>为边框指定宽度有两种方法：可以指定长度值，比如 2px 或 0.1em(单位为 px, pt, cm, em 等)，或者使用 3 个关键字之一，它们分别是 thick 、medium（默认值） 和 thin.</p>
<p>注意：CSS 没有定义 3 个关键字的具体宽度，所以一个用户可能把 thick 、medium 和 thin 分别设置为等于 5px、3px 和 2px，而另一个用户则分别设置为 3px、2px 和 1px.</p>
<pre><code class="language-css">p.one
{
    border-style:solid;
    border-width:5px;
}
p.two
{
    border-style:solid;
    border-width:medium;
}
</code></pre>
<h4 id="边框颜色"><a class="header" href="#边框颜色">边框颜色</a></h4>
<p><code>border-color</code>属性用于设置边框的颜色. 可以设置的颜色：</p>
<ul>
<li>name - 指定颜色的名称，如 &quot;red&quot;</li>
<li>RGB - 指定 RGB 值, 如 &quot;rgb(255,0,0)&quot;</li>
<li>Hex - 指定16进制值, 如 &quot;#ff0000&quot;</li>
</ul>
<pre><code class="language-css">p.one
{
    border-style:solid;
    border-color:red;
}
p.two
{
    border-style:solid;
    border-color:#98bf21;
}
</code></pre>
<h4 id="边框-单独设置各边"><a class="header" href="#边框-单独设置各边">边框-单独设置各边</a></h4>
<p>在CSS中，可以指定不同的侧面不同的边框：</p>
<pre><code class="language-css">p
{
    border-top-style:dotted;
    border-right-style:solid;
    border-bottom-style:dotted;
    border-left-style:solid;
}
</code></pre>
<p>上面的例子也可以设置一个单一属性：</p>
<pre><code class="language-css">border-style:dotted solid;
</code></pre>
<p><code>border-style</code>属性可以有1-4个值：</p>
<ul>
<li>
<p><strong>border-style:dotted solid double dashed</strong>;</p>
<ul>
<li>上边框是 dotted</li>
<li>右边框是 solid</li>
<li>底边框是 double</li>
<li>左边框是 dashed</li>
</ul>
</li>
<li>
<p><strong>border-style:dotted solid double</strong>;</p>
<ul>
<li>上边框是 dotted</li>
<li>左、右边框是 solid</li>
<li>底边框是 double</li>
</ul>
</li>
<li>
<p><strong>border-style:dotted solid</strong>;</p>
<ul>
<li>上、底边框是 dotted</li>
<li>右、左边框是 solid</li>
</ul>
</li>
<li>
<p><strong>border-style:dotted</strong>;</p>
<ul>
<li>四面边框是 dotted</li>
</ul>
</li>
</ul>
<p>上面的例子用了<code>border-style</code>. 然而，它也可以和border-width ,border-color一起使用</p>
<h3 id="css轮廓outline"><a class="header" href="#css轮廓outline">CSS轮廓(outline)</a></h3>
<p>轮廓（outline）是绘制于元素周围的一条线，位于边框边缘的外围，可起到突出元素的作用. CSS outline 属性规定元素轮廓的样式、颜色和宽度.</p>
<h4 id="所有css轮廓属性"><a class="header" href="#所有css轮廓属性">所有CSS轮廓属性</a></h4>
<div class="table-wrapper"><table><thead><tr><th>属性</th><th>说明</th><th>值</th></tr></thead><tbody>
<tr><td>outline</td><td>在一个声明中设置所有的轮廓属性</td><td>outline-color<br/>outline-style<br/>outline-width<br/>inherit</td></tr>
<tr><td>outline-color</td><td>设置轮廓的颜色</td><td>color-name<br/>hex-number<br/>rgb-number<br/>invert<br/>inherit</td></tr>
<tr><td>outline-style</td><td>设置轮廓的样式</td><td>none<br/>dotted<br/>dashed<br/>solid<br/>double<br/>groove<br/>ridge<br/>inset<br/>outset<br/>inherit</td></tr>
<tr><td>outline-width</td><td>设置轮廓的宽度</td><td>thin<br/>medium<br/>thick<br/>length<br/>inherit</td></tr>
</tbody></table>
</div>
<h3 id="css-margin外边距"><a class="header" href="#css-margin外边距">CSS margin(外边距)</a></h3>
<h4 id="margin"><a class="header" href="#margin">margin</a></h4>
<p>margin 清除周围的（外边框）元素区域. margin 没有背景颜色，是完全透明的. margin 可以单独改变元素的上，下，左，右边距，也可以一次改变所有的属性.</p>
<h4 id="可能的值"><a class="header" href="#可能的值">可能的值</a></h4>
<div class="table-wrapper"><table><thead><tr><th>值</th><th>说明</th></tr></thead><tbody>
<tr><td>auto</td><td>设置浏览器边距<br/>这样做的结果会依赖于浏览器</td></tr>
<tr><td>length</td><td>定义一个固定的margin（使用像素，pt，em等）</td></tr>
<tr><td>%</td><td>定义一个使用百分比的边距</td></tr>
</tbody></table>
</div>
<h4 id="margin---单边外边距属性"><a class="header" href="#margin---单边外边距属性">Margin - 单边外边距属性</a></h4>
<p>在CSS中，它可以指定不同的侧面不同的边距：</p>
<pre><code class="language-css">margin-top:100px;
margin-bottom:100px;
margin-right:50px;
margin-left:50px;
</code></pre>
<h3 id="css-padding填充"><a class="header" href="#css-padding填充">CSS padding(填充)</a></h3>
<p>当元素的 padding（填充）内边距被清除时，所释放的区域将会受到元素背景颜色的填充,</p>
<ul>
<li><code>length</code>: 定义一个固定的填充(像素, pt, em,等)</li>
<li><code>%</code>: 使用百分比值定义一个填充</li>
</ul>
<pre><code class="language-css">padding-top:25px;
padding-bottom:25px;
padding-right:50px;
padding-left:50px;
</code></pre>
<h3 id="css-分组-和-嵌套-选择器"><a class="header" href="#css-分组-和-嵌套-选择器">CSS 分组 和 嵌套 选择器</a></h3>
<h4 id="分组选择器"><a class="header" href="#分组选择器">分组选择器</a></h4>
<p>在样式表中有很多具有相同样式的元素</p>
<pre><code class="language-css">h1 {
    color:green;
}
h2 {
    color:green;
}
p {
    color:green;
}
</code></pre>
<p>为了尽量减少代码，你可以使用分组选择器, 每个选择器用逗号分隔. 在下面的例子中，我们对以上代码使用分组选择器：</p>
<pre><code class="language-css">h1,h2,p
{
    color:green;
}
</code></pre>
<h4 id="嵌套选择器"><a class="header" href="#嵌套选择器">嵌套选择器</a></h4>
<p>它可能适用于选择器内部的选择器的样式，在下面的例子设置了四个样式：</p>
<ul>
<li><code>p{ }</code>: 为所有 <code>p</code> 元素指定一个样式</li>
<li><code>.marked{ }</code>: 为所有 <code>class=&quot;marked&quot;</code> 的元素指定一个样式</li>
<li><code>.marked p{ }</code>: 为所有 <code>class=&quot;marked&quot;</code> 元素内的 <code>p</code> 元素指定一个样式</li>
<li><code>p.marked{ }</code>: 为所有 <code>class=&quot;marked&quot;</code> 的 <code>p</code> 元素指定一个样式</li>
</ul>
<pre><code class="language-css">p
{
    color:blue;
    text-align:center;
}
.marked
{
    background-color:red;
}
.marked p
{
    color:white;
}
p.marked{
    text-decoration:underline;
}
</code></pre>
<h3 id="css-尺寸-dimension"><a class="header" href="#css-尺寸-dimension">CSS 尺寸 (Dimension)</a></h3>
<p>CSS 尺寸 (Dimension) 属性允许你控制元素的高度和宽度. 同样，它允许你增加行间距.</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">属性</th><th style="text-align: center">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">height</td><td style="text-align: center">设置元素的高度</td></tr>
<tr><td style="text-align: center">line-height</td><td style="text-align: center">设置行高</td></tr>
<tr><td style="text-align: center">max-height</td><td style="text-align: center">设置元素最大高度</td></tr>
<tr><td style="text-align: center">max-width</td><td style="text-align: center">设置元素最大宽度</td></tr>
<tr><td style="text-align: center">min-height</td><td style="text-align: center">设置元素最小高度</td></tr>
<tr><td style="text-align: center">min-width</td><td style="text-align: center">设置元素最小宽度</td></tr>
<tr><td style="text-align: center">width</td><td style="text-align: center">设置元素宽度</td></tr>
</tbody></table>
</div>
<h3 id="css-display显示-与-visibility可见性"><a class="header" href="#css-display显示-与-visibility可见性">CSS Display(显示) 与 Visibility（可见性）</a></h3>
<p><code>display</code>属性设置一个元素应如何显示，<code>visibility</code>属性指定一个元素应可见还是隐藏.</p>
<h4 id="隐藏元素---displaynone或visibilityhidden"><a class="header" href="#隐藏元素---displaynone或visibilityhidden">隐藏元素 - <code>display:none</code>或<code>visibility:hidden</code></a></h4>
<p>隐藏一个元素可以通过把<code>display</code>属性设置为<code>&quot;none&quot;</code>，或把<code>visibility</code>属性设置为<code>&quot;hidden&quot;</code>. 但是请注意，这两种方法会产生不同的结果.</p>
<p><code>visibility:hidden</code>可以隐藏某个元素，但隐藏的元素仍需占用与未隐藏之前一样的空间. 也就是说，该元素虽然被隐藏了，但仍然会影响布局.</p>
<pre><code class="language-css">h1.hidden {visibility:hidden;}
</code></pre>
<p><code>display:none</code>可以隐藏某个元素，且隐藏的元素不会占用任何空间. 也就是说，该元素不但被隐藏了，而且该元素原本占用的空间也会从页面布局中消失.</p>
<pre><code class="language-css">h1.hidden {display:none;}
</code></pre>
<h4 id="css-display---块和内联元素"><a class="header" href="#css-display---块和内联元素">CSS Display - 块和内联元素</a></h4>
<p>块元素是一个元素，占用了全部宽度，在前后都是换行符.</p>
<p>块元素的例子：</p>
<ul>
<li><code>&lt;h1&gt;</code></li>
<li><code>&lt;p&gt;</code></li>
<li><code>&lt;div&gt;</code></li>
</ul>
<p>内联元素只需要必要的宽度，不强制换行.</p>
<p>内联元素的例子：</p>
<ul>
<li><code>&lt;span&gt;</code></li>
<li><code>&lt;a&gt;</code></li>
</ul>
<h4 id="如何改变一个元素显示"><a class="header" href="#如何改变一个元素显示">如何改变一个元素显示</a></h4>
<p>可以更改内联元素和块元素，反之亦然，可以使页面看起来是以一种特定的方式组合，并仍然遵循web标准.</p>
<p>下面的示例把列表项显示为内联元素：</p>
<pre><code class="language-css">li {display:inline;}
</code></pre>
<p>下面的示例把span元素作为块元素：</p>
<pre><code class="language-css">span {display:block;}
</code></pre>
<p>注意：变更元素的显示类型看该元素是如何显示，它是什么样的元素. 例如：一个内联元素设置为display:block是不允许有它内部的嵌套块元素.</p>
<h3 id="css-position定位"><a class="header" href="#css-position定位">CSS Position(定位)</a></h3>
<p>position 属性指定了元素的定位类型. position 属性的五个值：</p>
<ul>
<li><code>static</code></li>
<li><code>relative</code></li>
<li><code>fixed</code></li>
<li><code>absolute</code></li>
<li><code>sticky</code></li>
</ul>
<p>元素可以使用的顶部，底部，左侧和右侧属性定位. 然而，这些属性无法工作，除非是先设定position属性. 他们也有不同的工作方式，这取决于定位方法.</p>
<h4 id="static-定位"><a class="header" href="#static-定位">static 定位</a></h4>
<p>HTML 元素的默认值，即没有定位，遵循正常的文档流对象. 静态定位的元素不会受到 top, bottom, left, right影响.</p>
<pre><code class="language-css">div.static {
    position: static;
    border: 3px solid #73AD21;
}
</code></pre>
<h4 id="fixed-定位"><a class="header" href="#fixed-定位">fixed 定位</a></h4>
<p>元素的位置相对于浏览器窗口是固定位置. 即使窗口是滚动的它也不会移动：</p>
<pre><code class="language-css">p.pos_fixed
{
    position:fixed;
    top:30px;
    right:5px;
}
</code></pre>
<p><code>Fixed</code>定位使元素的位置与文档流无关，因此不占据空间. Fixed定位的元素和其他元素重叠。</p>
<h4 id="relative-定位"><a class="header" href="#relative-定位">relative 定位</a></h4>
<p>相对定位元素的定位是相对其正常位置.</p>
<pre><code class="language-css">h2.pos_left
{
    position:relative;
    left:-20px;
}
h2.pos_right
{
    position:relative;
    left:20px;
}
</code></pre>
<p>移动相对定位元素，但它原本所占的空间不会改变.</p>
<pre><code class="language-css">h2.pos_top
{
    position:relative;
    top:-50px;
}
</code></pre>
<p>相对定位元素经常被用来作为绝对定位元素的容器块.</p>
<h4 id="absolute-定位"><a class="header" href="#absolute-定位">absolute 定位</a></h4>
<p>绝对定位的元素的位置相对于最近的已定位父元素，如果元素没有已定位的父元素，那么它的位置相对于<code>&lt;html&gt;</code>:</p>
<pre><code class="language-css">h2
{
    position:absolute;
    left:100px;
    top:150px;
}
</code></pre>
<p>absolute 定位使元素的位置与文档流无关，因此不占据空间. absolute 定位的元素和其他元素重叠.</p>
<h4 id="sticky-定位"><a class="header" href="#sticky-定位">sticky 定位</a></h4>
<p><code>sticky</code> 英文字面意思是粘，粘贴，所以可以把它称之为粘性定位. <code>position: sticky</code>; 基于用户的滚动位置来定位. 粘性定位的元素是依赖于用户的滚动，在 <code>position:relative</code> 与  <code>position:fixed</code> 定位之间切换. 它的行为就像 <code>position:relative</code>; 而当页面滚动超出目标区域时，它的表现就像 <code>position:fixed</code>; 它会固定在目标位置. 元素定位表现为在跨越特定阈值前为相对定位，之后为固定定位.</p>
<p>这个特定阈值指的是 <code>top</code>, <code>right</code>, <code>bottom</code> 或 <code>left</code> 之一，换言之，指定 <code>top</code>, <code>right</code>, <code>bottom</code> 或 <code>left</code> 四个阈值其中之一，才可使粘性定位生效. 否则其行为与相对定位相同.</p>
<pre><code class="language-css">div.sticky {
    position: -webkit-sticky; /* Safari */
    position: sticky;
    top: 0;
    background-color: green;
    border: 2px solid #4CAF50;
}
</code></pre>
<h4 id="重叠的元素"><a class="header" href="#重叠的元素">重叠的元素</a></h4>
<p>元素的定位与文档流无关，所以它们可以覆盖页面上的其它元素. <code>z-index</code>属性指定了一个元素的堆叠顺序（哪个元素应该放在前面，或后面）. 一个元素可以有正数或负数的堆叠顺序：</p>
<pre><code class="language-css">img
{
    position:absolute;
    left:0px;
    top:0px;
    z-index:-1;
}
</code></pre>
<p>具有更高堆叠顺序的元素总是在较低的堆叠顺序元素的前面.
注意： 如果两个定位元素重叠，没有指定<code>z - index</code>，最后定位在HTML代码中的元素将被显示在最前面.</p>
<h3 id="css-布局---overflow"><a class="header" href="#css-布局---overflow">CSS 布局 - Overflow</a></h3>
<p>CSS <code>overflow</code> 属性用于控制内容溢出元素框时显示的方式. <code>overflow</code> 属性可以控制内容溢出元素框时在对应的元素区间内添加滚动条.</p>
<p><code>overflow</code>属性有以下值：</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">值</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">visible</td><td style="text-align: left">默认值. 内容不会被修剪，会呈现在元素框之外</td></tr>
<tr><td style="text-align: center">hidden</td><td style="text-align: left">内容会被修剪，并且其余内容是不可见的</td></tr>
<tr><td style="text-align: center">scroll</td><td style="text-align: left">内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容</td></tr>
<tr><td style="text-align: center">auto</td><td style="text-align: left">如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容</td></tr>
<tr><td style="text-align: center">inherit</td><td style="text-align: left">规定应该从父元素继承 overflow 属性的值</td></tr>
</tbody></table>
</div>
<p>注意:<code>overflow</code> 属性只工作于指定高度的块元素上. 默认情况下，<code>overflow</code> 的值为 <code>visible</code>， 意思是内容溢出元素框：</p>
<pre><code class="language-css">div {
    width: 200px;
    height: 50px;
    background-color: #eee;
    overflow: visible;
}
</code></pre>
<h3 id="css-float浮动"><a class="header" href="#css-float浮动">CSS Float(浮动)</a></h3>
<p>CSS 的 Float（浮动），会使元素向左或向右移动，其周围的元素也会重新排列. Float（浮动），往往是用于图像，但它在布局时一样非常有用.</p>
<p>元素的水平方向浮动，意味着元素只能左右移动而不能上下移动. 一个浮动元素会尽量向左或向右移动，直到它的外边缘碰到包含框或另一个浮动框的边框为止. 浮动元素之后的元素将围绕它. 浮动元素之前的元素将不会受到影响. 如果图像是右浮动，下面的文本流将环绕在它左边：</p>
<pre><code class="language-css">img
{
    float:right;
}
</code></pre>
<p>如果你把几个浮动的元素放到一起，如果有空间的话，它们将彼此相邻. 在这里，我们对图片廊使用 float 属性：</p>
<pre><code class="language-css">.thumbnail
{
    float:left;
    width:110px;
    height:90px;
    margin:5px;
}
</code></pre>
<p>清除浮动 - 元素浮动之后，周围的元素会重新排列，为了避免这种情况，使用 clear 属性.</p>
<p>clear 属性指定元素两侧不能出现浮动元素. 使用 clear 属性往文本中添加图片廊：</p>
<pre><code class="language-css">.text_line
{
    clear:both;
}
</code></pre>
<h3 id="css-布局---水平--垂直对齐"><a class="header" href="#css-布局---水平--垂直对齐">CSS 布局 - 水平 &amp; 垂直对齐</a></h3>
<h4 id="元素居中对齐"><a class="header" href="#元素居中对齐">元素居中对齐</a></h4>
<p>要水平居中对齐一个元素(如 <code>&lt;div&gt;</code>), 可以使用 <code>margin: auto;</code>. 设置到元素的宽度将防止它溢出到容器的边缘. 元素通过指定宽度，并将两边的空外边距平均分配：</p>
<pre><code class="language-css">.center {
    margin: auto;
    width: 50%;
    border: 3px solid green;
    padding: 10px;
}
</code></pre>
<p>注意: 如果没有设置 width 属性(或者设置 100%)，居中对齐将不起作用.</p>
<h4 id="文本居中对齐"><a class="header" href="#文本居中对齐">文本居中对齐</a></h4>
<p>如果仅仅是为了文本在元素内居中对齐，可以使用 text-align: center;</p>
<pre><code class="language-css">.center {
    text-align: center;
    border: 3px solid green;
}
</code></pre>
<h4 id="图片居中对齐"><a class="header" href="#图片居中对齐">图片居中对齐</a></h4>
<p>要让图片居中对齐, 可以使用 margin: auto; 并将它放到 块 元素中:</p>
<pre><code class="language-css">img {
    display: block;
    margin: auto;
    width: 40%;
}
</code></pre>
<h4 id="左右对齐---使用定位方式"><a class="header" href="#左右对齐---使用定位方式">左右对齐 - 使用定位方式</a></h4>
<p>我们可以使用 <code>position: absolute;</code> 属性来对齐元素:</p>
<pre><code class="language-css">.right {
    position: absolute;
    right: 0px;
    width: 300px;
    border: 3px solid #73AD21;
    padding: 10px;
}
</code></pre>
<p>注释：绝对定位元素会被从正常流中删除，并且能够交叠元素.
提示: 当使用 position 来对齐元素时, 通常 <code>&lt;body&gt;</code> 元素会设置 <code>margin</code> 和 <code>padding</code> . 这样可以避免在不同的浏览器中出现可见的差异.</p>
<pre><code class="language-css">body {
    margin: 0;
    padding: 0;
}

.container {
    position: relative;
    width: 100%;
}

.right {
    position: absolute;
    right: 0px;
    width: 300px;
    background-color: #b0e0e6;
}
</code></pre>
<h4 id="左右对齐---使用-float-方式"><a class="header" href="#左右对齐---使用-float-方式">左右对齐 - 使用 float 方式</a></h4>
<p>我们也可以使用 <code>float</code> 属性来对齐元素:</p>
<pre><code class="language-css">.right {
    float: right;
    width: 300px;
    border: 3px solid #73AD21;
    padding: 10px;
}
</code></pre>
<p>当像这样对齐元素时，对 <code>&lt;body&gt;</code> 元素的外边距和内边距进行预定义是一个好主意. 这样可以避免在不同的浏览器中出现可见的差异.</p>
<p>注意：如果子元素的高度大于父元素，且子元素设置了浮动，那么子元素将溢出，这时候你可以使用 <code>&quot;clearfix(清除浮动)&quot;</code> 来解决该问题.</p>
<p>我们可以在父元素上添加 <code>overflow: auto;</code> 来解决子元素溢出的问题:</p>
<pre><code class="language-css">.clearfix {
    overflow: auto;
}
</code></pre>
<pre><code class="language-css">body {
    margin: 0;
    padding: 0;
}

.right {
    float: right;
    width: 300px;
    background-color: #b0e0e6;
}
</code></pre>
<h4 id="垂直居中对齐---使用-padding"><a class="header" href="#垂直居中对齐---使用-padding">垂直居中对齐 - 使用 padding</a></h4>
<p>CSS 中有很多方式可以实现垂直居中对齐. 一个简单的方式就是头部顶部使用 <code>padding</code>:</p>
<pre><code class="language-css">.center {
    padding: 70px 0;
    border: 3px solid green;
}
</code></pre>
<p>如果要水平和垂直都居中，可以使用 <code>padding</code> 和 <code>text-align: center</code>:</p>
<pre><code class="language-css">.center {
    padding: 70px 0;
    border: 3px solid green;
    text-align: center;
}
</code></pre>
<h4 id="垂直居中---使用-line-height"><a class="header" href="#垂直居中---使用-line-height">垂直居中 - 使用 <code>line-height</code></a></h4>
<pre><code class="language-css">.center {
    line-height: 200px;
    height: 200px;
    border: 3px solid green;
    text-align: center;
}

/* 如果文本有多行，添加以下代码: */
.center p {
    line-height: 1.5;
    display: inline-block;
    vertical-align: middle;
}
</code></pre>
<h4 id="垂直居中---使用-position-和-transform"><a class="header" href="#垂直居中---使用-position-和-transform">垂直居中 - 使用 <code>position</code> 和 <code>transform</code></a></h4>
<p>除了使用 <code>padding</code> 和 <code>line-height</code> 属性外, 我们还可以使用 <code>transform</code> 属性来设置垂直居中:</p>
<pre><code class="language-css">.center {
    height: 200px;
    position: relative;
    border: 3px solid green;
}

.center p {
    margin: 0;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
}
</code></pre>
<h3 id="css-组合选择符"><a class="header" href="#css-组合选择符">CSS 组合选择符</a></h3>
<p>组合选择符说明了两个选择器之间的关系. CSS组合选择符包括各种简单选择符的组合方式. 在 CSS3 中包含了四种组合方式:</p>
<ul>
<li>后代选择器(以空格 <code> </code> 分隔)</li>
<li>子元素选择器(以大于 <code>&gt;</code> 号分隔）</li>
<li>相邻兄弟选择器（以加号 <code>+</code> 分隔）</li>
<li>普通兄弟选择器（以波浪号 <code>～</code> 分隔）</li>
</ul>
<h4 id="后代选择器"><a class="header" href="#后代选择器">后代选择器</a></h4>
<p>后代选择器用于选取某元素的后代元素. 以下实例选取所有 <code>&lt;p&gt;</code> 元素插入到 <code>&lt;div&gt;</code> 元素中:</p>
<pre><code class="language-css">div p
{
  background-color:yellow;
}
</code></pre>
<h4 id="子元素选择器"><a class="header" href="#子元素选择器">子元素选择器</a></h4>
<p>与后代选择器相比，子元素选择器（Child selectors）只能选择作为某元素直接/一级子元素的元素. 以下实例选择了<code>&lt;div&gt;</code>元素中所有直接子元素 <code>&lt;p&gt;</code> ：</p>
<pre><code class="language-css">div&gt;p
{
  background-color:yellow;
}
</code></pre>
<h4 id="相邻兄弟选择器"><a class="header" href="#相邻兄弟选择器">相邻兄弟选择器</a></h4>
<p>相邻兄弟选择器（Adjacent sibling selector）可选择紧接在另一元素后的元素，且二者有相同父元素. 如果需要选择紧接在另一个元素后的元素，而且二者有相同的父元素，可以使用相邻兄弟选择器（Adjacent sibling selector）. 以下实例选取了所有位于 <code>&lt;div&gt;</code> 元素后的第一个 <code>&lt;p&gt;</code> 元素:</p>
<pre><code class="language-css">div+p
{
  background-color:yellow;
}
</code></pre>
<h4 id="后续兄弟选择器"><a class="header" href="#后续兄弟选择器">后续兄弟选择器</a></h4>
<p>后续兄弟选择器选取所有指定元素之后的相邻兄弟元素. 以下实例选取了所有 <code>&lt;div&gt;</code> 元素之后的所有相邻兄弟元素 <code>&lt;p&gt;</code> :</p>
<pre><code class="language-css">div~p
{
  background-color:yellow;
}
</code></pre>
<h3 id="css-伪类pseudo-classes"><a class="header" href="#css-伪类pseudo-classes">CSS 伪类(Pseudo-classes)</a></h3>
<p>CSS伪类是用来添加一些选择器的特殊效果.</p>
<h4 id="语法"><a class="header" href="#语法">语法</a></h4>
<p>伪类的语法：<code>selector:pseudo-class {property:value;}</code>
CSS类也可以使用伪类：<code>selector.class:pseudo-class {property:value;}</code></p>
<h4 id="anchor伪类"><a class="header" href="#anchor伪类">anchor伪类</a></h4>
<p>在支持 CSS 的浏览器中，链接的不同状态都可以以不同的方式显示</p>
<pre><code class="language-css">a:link {color:#FF0000;} /* 未访问的链接 */
a:visited {color:#00FF00;} /* 已访问的链接 */
a:hover {color:#FF00FF;} /* 鼠标划过链接 */
a:active {color:#0000FF;} /* 已选中的链接 */
</code></pre>
<p>注意： 在CSS定义中，<code>a:hover</code> 必须被置于 <code>a:link</code> 和 <code>a:visited</code> 之后，才是有效的
注意： 在 CSS 定义中，<code>a:active</code> 必须被置于 <code>a:hover</code> 之后，才是有效的
注意：伪类的名称不区分大小写</p>
<h4 id="伪类和css类"><a class="header" href="#伪类和css类">伪类和CSS类</a></h4>
<p>伪类可以与 CSS 类配合使用：</p>
<pre><code class="language-css">a.red:visited {color:#FF0000;}

&lt;a class=&quot;red&quot; href=&quot;css-syntax.html&quot;&gt;CSS 语法&lt;/a&gt;
</code></pre>
<p>如果在上面的例子的链接已被访问，它会显示为红色.</p>
<h4 id="css-first-child-伪类"><a class="header" href="#css-first-child-伪类">CSS <code>:first-child</code> 伪类</a></h4>
<p>您可以使用 <code>:first-child</code> 伪类来选择父元素的第一个子元素.</p>
<h4 id="匹配第一个-p-元素"><a class="header" href="#匹配第一个-p-元素">匹配第一个 <code>&lt;p&gt;</code> 元素</a></h4>
<p>在下面的例子中，选择器匹配作为任何元素的第一个子元素的 <code>&lt;p&gt;</code> 元素：</p>
<pre><code class="language-css">p:first-child
{
    color:blue;
}
</code></pre>
<h4 id="匹配所有-p-元素中的第一个-i-元素"><a class="header" href="#匹配所有-p-元素中的第一个-i-元素">匹配所有 <code>&lt;p&gt;</code> 元素中的第一个 <code>&lt;i&gt;</code> 元素</a></h4>
<p>在下面的例子中，选择相匹配的所有<code>&lt;p&gt;</code>元素的第一个 <code>&lt;i&gt;</code> 元素：</p>
<pre><code class="language-css">p &gt; i:first-child
{
    color:blue;
}
</code></pre>
<h4 id="匹配所有作为第一个子元素的-p-元素中的所有-i-元素"><a class="header" href="#匹配所有作为第一个子元素的-p-元素中的所有-i-元素">匹配所有作为第一个子元素的 <code>&lt;p&gt;</code> 元素中的所有 <code>&lt;i&gt;</code> 元素</a></h4>
<p>在下面的例子中，选择器匹配所有作为元素的第一个子元素的 <code>&lt;p&gt;</code> 元素中的所有 <code>&lt;i&gt;</code> 元素：</p>
<pre><code class="language-css">p:first-child i
{
    color:blue;
}
</code></pre>
<h4 id="css---lang-伪类"><a class="header" href="#css---lang-伪类">CSS - <code>:lang</code> 伪类</a></h4>
<p><code>:lang</code> 伪类使你有能力为不同的语言定义特殊的规则</p>
<p>在下面的例子中，<code>:lang</code> 类为属性值为 <code>no</code> 的<code>q</code>元素定义引号的类型：</p>
<pre><code class="language-css">q:lang(no) {quotes: &quot;~&quot; &quot;~&quot;;}
</code></pre>
<h4 id="所有css伪类元素"><a class="header" href="#所有css伪类元素">所有CSS伪类/元素</a></h4>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">选择器</th><th style="text-align: left">示例</th><th style="text-align: left">示例说明</th></tr></thead><tbody>
<tr><td style="text-align: left">:checked</td><td style="text-align: left">input:checked</td><td style="text-align: left">选择所有选中的表单元素</td></tr>
<tr><td style="text-align: left">:disabled</td><td style="text-align: left">input:disabled</td><td style="text-align: left">选择所有禁用的表单元素</td></tr>
<tr><td style="text-align: left">:empty</td><td style="text-align: left">p:empty</td><td style="text-align: left">选择所有没有子元素的p元素</td></tr>
<tr><td style="text-align: left">:enabled</td><td style="text-align: left">input:enabled	选择所有启用的表单元素</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">:first-of-type</td><td style="text-align: left">p:first-of-type</td><td style="text-align: left">选择的每个 p 元素是其父元素的第一个 p 元素</td></tr>
<tr><td style="text-align: left">:in-range</td><td style="text-align: left">input:in-range</td><td style="text-align: left">选择元素指定范围内的值</td></tr>
<tr><td style="text-align: left">:invalid</td><td style="text-align: left">input:invalid</td><td style="text-align: left">选择所有无效的元素</td></tr>
<tr><td style="text-align: left">:last-child</td><td style="text-align: left">p:last-child</td><td style="text-align: left">选择所有p元素的最后一个子元素</td></tr>
<tr><td style="text-align: left">:last-of-type</td><td style="text-align: left">p:last-of-type</td><td style="text-align: left">选择每个p元素是其母元素的最后一个p元素</td></tr>
<tr><td style="text-align: left">:not(selector)</td><td style="text-align: left">:not(p)</td><td style="text-align: left">选择所有p以外的元素</td></tr>
<tr><td style="text-align: left">:nth-child(n)</td><td style="text-align: left">p:nth-child(2)</td><td style="text-align: left">选择所有 p 元素的父元素的第二个子元素</td></tr>
<tr><td style="text-align: left">:nth-last-child(n)</td><td style="text-align: left">p:nth-last-child(2)</td><td style="text-align: left">选择所有p元素倒数的第二个子元素</td></tr>
<tr><td style="text-align: left">:nth-last-of-type(n)</td><td style="text-align: left">p:nth-last-of-type(2)</td><td style="text-align: left">选择所有p元素倒数的第二个为p的子元素</td></tr>
<tr><td style="text-align: left">:nth-of-type(n)</td><td style="text-align: left">p:nth-of-type(2)</td><td style="text-align: left">选择所有p元素第二个为p的子元素</td></tr>
<tr><td style="text-align: left">:only-of-type</td><td style="text-align: left">p:only-of-type</td><td style="text-align: left">选择所有仅有一个子元素为p的元素</td></tr>
<tr><td style="text-align: left">:only-child</td><td style="text-align: left">p:only-child</td><td style="text-align: left">选择所有仅有一个子元素的p元素</td></tr>
<tr><td style="text-align: left">:optional</td><td style="text-align: left">input:optional</td><td style="text-align: left">选择没有&quot;required&quot;的元素属性</td></tr>
<tr><td style="text-align: left">:out-of-range</td><td style="text-align: left">input:out-of-range</td><td style="text-align: left">选择指定范围以外的值的元素属性</td></tr>
<tr><td style="text-align: left">:read-only</td><td style="text-align: left">input:read-only</td><td style="text-align: left">选择只读属性的元素属性</td></tr>
<tr><td style="text-align: left">:read-write</td><td style="text-align: left">input:read-write</td><td style="text-align: left">选择没有只读属性的元素属性</td></tr>
<tr><td style="text-align: left">:required</td><td style="text-align: left">input:required</td><td style="text-align: left">选择有&quot;required&quot;属性指定的元素属性</td></tr>
<tr><td style="text-align: left">:root</td><td style="text-align: left">root</td><td style="text-align: left">选择文档的根元素</td></tr>
<tr><td style="text-align: left">:target</td><td style="text-align: left">#news:target</td><td style="text-align: left">选择当前活动#news元素(点击URL包含锚的名字)</td></tr>
<tr><td style="text-align: left">:valid</td><td style="text-align: left">input:valid</td><td style="text-align: left">选择所有有效值的属性</td></tr>
<tr><td style="text-align: left">:link</td><td style="text-align: left">a:link</td><td style="text-align: left">选择所有未访问链接</td></tr>
<tr><td style="text-align: left">:visited</td><td style="text-align: left">a:visited</td><td style="text-align: left">选择所有访问过的链接</td></tr>
<tr><td style="text-align: left">:active</td><td style="text-align: left">a:active</td><td style="text-align: left">选择正在活动链接</td></tr>
<tr><td style="text-align: left">:hover</td><td style="text-align: left">a:hover</td><td style="text-align: left">把鼠标放在链接上的状态</td></tr>
<tr><td style="text-align: left">:focus</td><td style="text-align: left">input:focus</td><td style="text-align: left">选择元素输入后具有焦点</td></tr>
<tr><td style="text-align: left">:first-letter</td><td style="text-align: left">p:first-letter</td><td style="text-align: left">选择每个<code>&lt;p&gt; </code>元素的第一个字母</td></tr>
<tr><td style="text-align: left">:first-line</td><td style="text-align: left">p:first-line</td><td style="text-align: left">选择每个<code>&lt;p&gt; </code>元素的第一行</td></tr>
<tr><td style="text-align: left">:first-child</td><td style="text-align: left">p:first-child</td><td style="text-align: left">选择器匹配属于任意元素的第一个子元素的 <code>&lt;p&gt; </code>元素</td></tr>
<tr><td style="text-align: left">:before</td><td style="text-align: left">p:before</td><td style="text-align: left">在每个<code>&lt;p&gt;</code>元素之前插入内容</td></tr>
<tr><td style="text-align: left">:after</td><td style="text-align: left">p:after</td><td style="text-align: left">在每个<code>&lt;p&gt;</code>元素之后插入内容</td></tr>
<tr><td style="text-align: left">:lang(language)</td><td style="text-align: left">p:lang(it)</td><td style="text-align: left">为<code>&lt;p&gt;</code>元素的lang属性选择一个开始值</td></tr>
</tbody></table>
</div>
<h3 id="css-伪元素"><a class="header" href="#css-伪元素">CSS 伪元素</a></h3>
<p>CSS 伪元素是用来添加一些选择器的特殊效果</p>
<p>伪元素的语法：</p>
<pre><code class="language-css">selector:pseudo-element {property:value;}
</code></pre>
<p>CSS类也可以使用伪元素：</p>
<pre><code class="language-css">selector.class:pseudo-element {property:value;}
</code></pre>
<h4 id="first-line-伪元素"><a class="header" href="#first-line-伪元素"><code>:first-line</code> 伪元素</a></h4>
<p><code>&quot;first-line&quot;</code> 伪元素用于向文本的首行设置特殊样式. 在下面的例子中，浏览器会根据 <code>&quot;first-line&quot;</code> 伪元素中的样式对 <code>p</code> 元素的第一行文本进行格式化：</p>
<pre><code class="language-css">p:first-line
{
    color:#ff0000;
    font-variant:small-caps;
}
</code></pre>
<p>注意：<code>&quot;first-line&quot;</code> 伪元素只能用于块级元素
注意： 下面的属性可应用于 <code>&quot;first-line&quot;</code> 伪元素：</p>
<ul>
<li><code>font properties</code></li>
<li><code>color properties</code></li>
<li><code>background properties</code></li>
<li><code>word-spacing</code></li>
<li><code>letter-spacing</code></li>
<li><code>text-decoration</code></li>
<li><code>vertical-align</code></li>
<li><code>text-transform</code></li>
<li><code>line-height</code></li>
<li><code>clear</code></li>
</ul>
<h4 id="first-letter-伪元素"><a class="header" href="#first-letter-伪元素"><code>:first-letter</code> 伪元素</a></h4>
<p><code>&quot;first-letter&quot;</code> 伪元素用于向文本的首字母设置特殊样式：</p>
<pre><code class="language-css">p:first-letter
{
    color:#ff0000;
    font-size:xx-large;
}
</code></pre>
<p>注意： <code>&quot;first-letter&quot;</code> 伪元素只能用于块级元素
注意： 下面的属性可应用于 <code>&quot;first-letter&quot;</code> 伪元素：</p>
<ul>
<li><code>font properties</code></li>
<li><code>color properties</code></li>
<li><code>background properties</code></li>
<li><code>margin properties</code></li>
<li><code>padding properties</code></li>
<li><code>border properties</code></li>
<li><code>text-decoration</code></li>
<li><code>vertical-align</code> (only if <code>&quot;float&quot;</code> is <code>&quot;none&quot;</code>)</li>
<li><code>text-transform</code></li>
<li><code>line-height</code></li>
<li><code>float</code></li>
<li><code>clear</code></li>
</ul>
<h4 id="伪元素和css类"><a class="header" href="#伪元素和css类">伪元素和CSS类</a></h4>
<p>伪元素可以结合CSS类：</p>
<pre><code class="language-css">p.article:first-letter {color:#ff0000;}

&lt;p class=&quot;article&quot;&gt;文章段落&lt;/p&gt;
</code></pre>
<p>上面的例子会使所有 <code>class</code> 为 <code>article</code> 的段落的首字母变为红色。</p>
<h4 id="多个伪元素"><a class="header" href="#多个伪元素">多个伪元素</a></h4>
<p>可以结合多个伪元素来使用. 在下面的例子中，段落的第一个字母将显示为红色，其字体大小为 <code>xx-large</code>. 第一行中的其余文本将为蓝色，并以小型大写字母显示. 段落中的其余文本将以默认字体大小和颜色来显示：</p>
<pre><code class="language-css">p:first-letter
{
    color:#ff0000;
    font-size:xx-large;
}
p:first-line
{
    color:#0000ff;
    font-variant:small-caps;
}
</code></pre>
<h4 id="css---before-伪元素"><a class="header" href="#css---before-伪元素">CSS - <code>:before</code> 伪元素</a></h4>
<p><code>&quot;:before&quot;</code> 伪元素可以在元素的内容前面插入新内容. 下面的例子在每个 <code>&lt;h1&gt;</code>元素前面插入一幅图片：</p>
<pre><code class="language-css">h1:before
{
    content:url(smiley.gif);
}
</code></pre>
<h4 id="css---after-伪元素"><a class="header" href="#css---after-伪元素">CSS - <code>:after</code> 伪元素</a></h4>
<p><code>&quot;:after&quot;</code> 伪元素可以在元素的内容之后插入新内容. 下面的例子在每个 <code>&lt;h1&gt;</code> 元素后面插入一幅图片：</p>
<pre><code class="language-css">h1:after
{
    content:url(smiley.gif);
}
</code></pre>
<h4 id="所有css伪类元素-1"><a class="header" href="#所有css伪类元素-1">所有CSS伪类/元素</a></h4>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">选择器</th><th style="text-align: center">示例</th><th style="text-align: center">示例说明</th></tr></thead><tbody>
<tr><td style="text-align: center">:link</td><td style="text-align: center">a:link</td><td style="text-align: center">选择所有未访问链接</td></tr>
<tr><td style="text-align: center">:visited</td><td style="text-align: center">a:visited</td><td style="text-align: center">选择所有访问过的链接</td></tr>
<tr><td style="text-align: center">:active</td><td style="text-align: center">a:active</td><td style="text-align: center">选择正在活动链接</td></tr>
<tr><td style="text-align: center">:hover</td><td style="text-align: center">a:hover</td><td style="text-align: center">把鼠标放在链接上的状态</td></tr>
<tr><td style="text-align: center">:focus</td><td style="text-align: center">input:focus</td><td style="text-align: center">选择元素输入后具有焦点</td></tr>
<tr><td style="text-align: center">:first-letter</td><td style="text-align: center">p:first-letter</td><td style="text-align: center">选择每个<code>&lt;p&gt;</code> 元素的第一个字母</td></tr>
<tr><td style="text-align: center">:first-line</td><td style="text-align: center">p:first-line</td><td style="text-align: center">选择每个<code>&lt;p&gt;</code> 元素的第一行</td></tr>
<tr><td style="text-align: center">:first-child</td><td style="text-align: center">p:first-child</td><td style="text-align: center">选择器匹配属于任意元素的第一个子元素的 <code>&lt;p&gt;</code> 元素</td></tr>
<tr><td style="text-align: center">:before</td><td style="text-align: center">p:before</td><td style="text-align: center">在每个<code>&lt;p&gt;</code>元素之前插入内容</td></tr>
<tr><td style="text-align: center">:after</td><td style="text-align: center">p:after</td><td style="text-align: center">在每个<code>&lt;p&gt;</code>元素之后插入内容</td></tr>
<tr><td style="text-align: center">:lang(language)</td><td style="text-align: center">p:lang(it)</td><td style="text-align: center">为<code>&lt;p&gt;</code>元素的lang属性选择一个开始值</td></tr>
</tbody></table>
</div>
<h3 id="css-导航栏"><a class="header" href="#css-导航栏">CSS 导航栏</a></h3>
<p>使用CSS你可以转换成好看的导航栏而不是枯燥的HTML菜单.</p>
<h4 id="导航栏链接列表"><a class="header" href="#导航栏链接列表">导航栏=链接列表</a></h4>
<p>在我们的例子中我们将建立一个标准的 HTML 列表导航栏. 导航条基本上是一个链接列表，所以使用 <code>&lt;ul&gt;</code> 和 <code>&lt;li&gt;</code>元素非常有意义：</p>
<pre><code class="language-css">&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#home&quot;&gt;主页&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#news&quot;&gt;新闻&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#contact&quot;&gt;联系&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#about&quot;&gt;关于&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>现在，让我们从列表中删除边距和填充：</p>
<pre><code class="language-css">ul {
    list-style-type: none;
    margin: 0;
    padding: 0;
}
</code></pre>
<p>例子解析：</p>
<ul>
<li><code>list-style-type:none</code> - 移除列表前小标志. 一个导航栏并不需要列表标记</li>
<li>移除浏览器的默认设置将边距和填充设置为<code>0</code>
上面的例子中的代码是垂直和水平导航栏使用的标准代码.</li>
</ul>
<h4 id="垂直导航栏"><a class="header" href="#垂直导航栏">垂直导航栏</a></h4>
<p>上面的代码，我们只需要 <code>&lt;a&gt;</code>元素的样式，建立一个垂直的导航栏：</p>
<pre><code class="language-css">a
{
    display:block;
    width:60px;
}
</code></pre>
<p>示例说明：</p>
<ul>
<li><code>display:block</code> - 显示块元素的链接，让整体变为可点击链接区域（不只是文本），它允许我们指定宽度</li>
<li><code>width:60px</code> - 块元素默认情况下是最大宽度. 我们要指定一个60像素的宽度</li>
</ul>
<p>注意： 请务必指定 <code>&lt;a&gt;</code>元素在垂直导航栏的的宽度. 如果省略宽度，IE6可能产生意想不到的效果.</p>
<h4 id="垂直导航条实例"><a class="header" href="#垂直导航条实例">垂直导航条实例</a></h4>
<p>创建一个简单的垂直导航条实例，在鼠标移动到选项时，修改背景颜色：</p>
<pre><code class="language-css">ul {
    list-style-type: none;
    margin: 0;
    padding: 0;
    width: 200px;
    background-color: #f1f1f1;
}

li a {
    display: block;
    color: #000;
    padding: 8px 16px;
    text-decoration: none;
}

/* 鼠标移动到选项上修改背景颜色 */
li a:hover {
    background-color: #555;
    color: white;
}
</code></pre>
<h4 id="激活当前导航条实例"><a class="header" href="#激活当前导航条实例">激活/当前导航条实例</a></h4>
<p>在点击了选项后，我们可以添加 <code>&quot;active&quot;</code> 类来标注哪个选项被选中：</p>
<pre><code class="language-css">li a.active {
    background-color: #4CAF50;
    color: white;
}
</code></pre>
<h4 id="创建链接并添加边框"><a class="header" href="#创建链接并添加边框">创建链接并添加边框</a></h4>
<p>可以在 <code>&lt;li&gt;</code> or <code>&lt;a&gt;</code>上添加 <code>text-align:center</code> 样式来让链接居中.
可以在 border <code>&lt;ul&gt;</code> 上添加 <code>border</code> 属性来让导航栏有边框. 如果要在每个选项上添加边框，可以在每个 <code>&lt;li&gt;</code> 元素上添加border-bottom :</p>
<pre><code class="language-css">ul {
    border: 1px solid #555;
}

li {
    text-align: center;
    border-bottom: 1px solid #555;
}

li:last-child {
    border-bottom: none;
}
</code></pre>
<h4 id="全屏高度的固定导航条"><a class="header" href="#全屏高度的固定导航条">全屏高度的固定导航条</a></h4>
<p>接下来我们创建一个左边是全屏高度的固定导航条，右边是可滚动的内容.</p>
<pre><code class="language-css">ul {
    list-style-type: none;
    margin: 0;
    padding: 0;
    width: 25%;
    background-color: #f1f1f1;
    height: 100%; /* 全屏高度 */
    position: fixed;
    overflow: auto; /* 如果导航栏选项多，允许滚动 */
}
</code></pre>
<h4 id="水平导航栏"><a class="header" href="#水平导航栏">水平导航栏</a></h4>
<p>有两种方法创建横向导航栏. 使用内联(inline)或浮动(float)的列表项. 这两种方法都很好，但如果你想链接到具有相同的大小，你必须使用浮动的方法.</p>
<h4 id="内联列表项"><a class="header" href="#内联列表项">内联列表项</a></h4>
<p>建立一个横向导航栏的方法之一是指定元素， 下述代码是标准的内联:</p>
<pre><code class="language-css">li
{
    display:inline;
}
</code></pre>
<p>实例解析：</p>
<ul>
<li><code>display:inline;</code> - 默认情况下，<code>&lt;li&gt;</code> 元素是块元素. 在这里，我们删除换行符之前和之后每个列表项，以显示一行</li>
</ul>
<h4 id="浮动列表项"><a class="header" href="#浮动列表项">浮动列表项</a></h4>
<p>在上面的例子中链接有不同的宽度. 对于所有的链接宽度相等，浮动 <code>&lt;li&gt;</code>元素，并指定为 <code>&lt;a&gt;</code>元素的宽度：</p>
<pre><code class="language-css">li
{
    float:left;
}
a
{
    display:block;
    width:60px;
}
</code></pre>
<p>实例解析：</p>
<ul>
<li><code>float:left</code> - 使用浮动块元素的幻灯片彼此相邻</li>
<li><code>display:block</code> - 显示块元素的链接，让整体变为可点击链接区域（不只是文本），它允许我们指定宽度</li>
<li><code>width:60px</code> - 块元素默认情况下是最大宽度. 我们要指定一个60像素的宽度</li>
</ul>
<h4 id="水平导航条实例"><a class="header" href="#水平导航条实例">水平导航条实例</a></h4>
<p>创建一个水平导航条，在鼠标移动到选项后修改背景颜色.</p>
<pre><code class="language-css">ul {
    list-style-type: none;
    margin: 0;
    padding: 0;
    overflow: hidden;
    background-color: #333;
}

li {
    float: left;
}

li a {
    display: block;
    color: white;
    text-align: center;
    padding: 14px 16px;
    text-decoration: none;
}

/*鼠标移动到选项上修改背景颜色 */
li a:hover {
    background-color: #111;
}
</code></pre>
<h4 id="激活当前导航条实例-1"><a class="header" href="#激活当前导航条实例-1">激活/当前导航条实例</a></h4>
<p>在点击了选项后，我们可以添加 <code>&quot;active&quot;</code> 类来标准哪个选项被选中：</p>
<pre><code class="language-css">.active {
    background-color: #4CAF50;
}
</code></pre>
<h4 id="链接右对齐"><a class="header" href="#链接右对齐">链接右对齐</a></h4>
<p>将导航条最右边的选项设置右对齐 (<code>float:right;</code>)：</p>
<pre><code class="language-css">&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#home&quot;&gt;主页&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#news&quot;&gt;新闻&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#contact&quot;&gt;联系&lt;/a&gt;&lt;/li&gt;
  &lt;li style=&quot;float:right&quot;&gt;&lt;a class=&quot;active&quot; href=&quot;#about&quot;&gt;关于&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<h4 id="添加分割线"><a class="header" href="#添加分割线">添加分割线</a></h4>
<p><code>&lt;li&gt;</code> 通过 <code>border-right</code> 样式来添加分割线:</p>
<pre><code class="language-css">/* 除了最后一个选项(last-child) 其他的都添加分割线 */
li {
    border-right: 1px solid #bbb;
}

li:last-child {
    border-right: none;
}
</code></pre>
<h4 id="固定导航条"><a class="header" href="#固定导航条">固定导航条</a></h4>
<p>可以设置页面的导航条固定在头部或者底部：</p>
<p>固定在头部</p>
<pre><code class="language-css">ul {
    position: fixed;
    top: 0;
    width: 100%;
}
</code></pre>
<p>固定在底部</p>
<pre><code class="language-css">ul {
    position: fixed;
    bottom: 0;
    width: 100%;
}
</code></pre>
<h4 id="灰色水平导航条"><a class="header" href="#灰色水平导航条">灰色水平导航条</a></h4>
<pre><code class="language-css">ul {
    border: 1px solid #e7e7e7;
    background-color: #f3f3f3;
}

li a {
    color: #666;
}
</code></pre>
<h3 id="css-下拉菜单"><a class="header" href="#css-下拉菜单">CSS 下拉菜单</a></h3>
<p>使用 CSS 创建一个鼠标移动上去后显示下拉菜单的效果</p>
<pre><code class="language-html">&lt;style&gt;
.dropdown {
  position: relative;
  display: inline-block;
}
.dropdown-content {
  display: none;
  position: absolute;
  background-color: #f9f9f9;
  min-width: 160px;
  box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
  padding: 12px 16px;
}
.dropdown:hover .dropdown-content {
  display: block;
}
&lt;/style&gt;
&lt;div class=&quot;dropdown&quot;&gt;
  &lt;span&gt;鼠标移动到我这！&lt;/span&gt;
  &lt;div class=&quot;dropdown-content&quot;&gt;
    &lt;p&gt;菜鸟教程&lt;/p&gt;
    &lt;p&gt;www.runoob.com&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>实例解析
<strong>HTML 部分</strong>：
我们可以使用任何的 HTML 元素来打开下拉菜单，如：<code>&lt;span&gt;</code>, 或 a <code>&lt;button&gt;</code> 元素.
使用容器元素 (如： <code>&lt;div&gt;</code>) 来创建下拉菜单的内容，并放在任何你想放的位置上.
使用 <code>&lt;div&gt;</code> 元素来包裹这些元素，并使用 CSS 来设置下拉内容的样式.</p>
<p><strong>CSS 部分</strong>：
<code>.dropdown</code> 类使用 <code>position:relative</code>, 这将设置下拉菜单的内容放置在下拉按钮 (使用 <code>position:absolute</code>) 的右下角位置.</p>
<p><code>.dropdown-content</code> 类中是实际的下拉菜单. 默认是隐藏的，在鼠标移动到指定元素后会显示. 注意 <code>min-width</code> 的值设置为 <code>160px</code>. 你可以随意修改它. 注意: 如果你想设置下拉内容与下拉按钮的宽度一致，可设置 <code>width</code> 为 <code>100%</code> ( <code>overflow:auto</code> 设置可以在小尺寸屏幕上滚动).</p>
<p>我们使用 <code>box-shadow</code> 属性让下拉菜单看起来像一个&quot;卡片&quot;.</p>
<p><code>:hover</code> 选择器用于在用户将鼠标移动到下拉按钮上时显示下拉菜单.</p>
<h4 id="下拉菜单"><a class="header" href="#下拉菜单">下拉菜单</a></h4>
<p>创建下拉菜单，并允许用户选取列表中的某一项. 这个实例类似前面的实例，当我们在下拉列表中添加了链接，并设置了样式：</p>
<pre><code class="language-html">&lt;style&gt;
/* 下拉按钮样式 */
.dropbtn {
    background-color: #4CAF50;
    color: white;
    padding: 16px;
    font-size: 16px;
    border: none;
    cursor: pointer;
}

/* 容器 &lt;div&gt; - 需要定位下拉内容 */
.dropdown {
    position: relative;
    display: inline-block;
}

/* 下拉内容 (默认隐藏) */
.dropdown-content {
    display: none;
    position: absolute;
    background-color: #f9f9f9;
    min-width: 160px;
    box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
}

/* 下拉菜单的链接 */
.dropdown-content a {
    color: black;
    padding: 12px 16px;
    text-decoration: none;
    display: block;
}

/* 鼠标移上去后修改下拉菜单链接颜色 */
.dropdown-content a:hover {background-color: #f1f1f1}

/* 在鼠标移上去后显示下拉菜单 */
.dropdown:hover .dropdown-content {
    display: block;
}

/* 当下拉内容显示后修改下拉按钮的背景颜色 */
.dropdown:hover .dropbtn {
    background-color: #3e8e41;
}
&lt;/style&gt;

&lt;div class=&quot;dropdown&quot;&gt;
  &lt;button class=&quot;dropbtn&quot;&gt;下拉菜单&lt;/button&gt;
  &lt;div class=&quot;dropdown-content&quot;&gt;
    &lt;a href=&quot;#&quot;&gt;菜鸟教程 1&lt;/a&gt;
    &lt;a href=&quot;#&quot;&gt;菜鸟教程 2&lt;/a&gt;
    &lt;a href=&quot;#&quot;&gt;菜鸟教程 3&lt;/a&gt;
  &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<h4 id="下拉内容对齐方式"><a class="header" href="#下拉内容对齐方式">下拉内容对齐方式</a></h4>
<p>如果你想设置右浮动的下拉菜单内容方向是从右到左，而不是从左到右，可以添加以下代码 <code>right: 0;</code></p>
<pre><code class="language-css">.dropdown-content {
    right: 0;
}
</code></pre>
<h3 id="css-提示工具tooltip"><a class="header" href="#css-提示工具tooltip">CSS 提示工具(Tooltip)</a></h3>
<p>提示工具在鼠标移动到指定元素后触发</p>
<h4 id="基础提示框tooltip"><a class="header" href="#基础提示框tooltip">基础提示框(Tooltip)</a></h4>
<p>提示框在鼠标移动到指定元素上显示：</p>
<pre><code class="language-html">&lt;style&gt;
/* Tooltip 容器 */
.tooltip {
    position: relative;
    display: inline-block;
    border-bottom: 1px dotted black; /* 悬停元素上显示点线 */
}

/* Tooltip 文本 */
.tooltip .tooltiptext {
    visibility: hidden;
    width: 120px;
    background-color: black;
    color: #fff;
    text-align: center;
    padding: 5px 0;
    border-radius: 6px;

    /* 定位 */
    position: absolute;
    z-index: 1;
}

/* 鼠标移动上去后显示提示框 */
.tooltip:hover .tooltiptext {
    visibility: visible;
}
&lt;/style&gt;

&lt;div class=&quot;tooltip&quot;&gt;鼠标移动到这
  &lt;span class=&quot;tooltiptext&quot;&gt;提示文本&lt;/span&gt;
&lt;/div&gt;
</code></pre>
<p>实例解析</p>
<p>HTML-使用容器元素 (like <code>&lt;div&gt;</code>) 并添加 <code>&quot;tooltip&quot;</code> 类. 在鼠标移动到 <code>&lt;div&gt;</code> 上时显示提示信息.</p>
<p>提示文本放在内联元素上(如 <code>&lt;span&gt;</code>) 并使用<code>class=&quot;tooltiptext&quot;</code></p>
<p>CSS-<code>tooltip</code> 类使用 <code>position:relative</code>, 提示文本需要设置定位值 <code>position:absolute</code>. 注意: 接下来的实例会显示更多的定位效果.</p>
<p><code>tooltiptext</code> 类用于实际的提示文本. 模式是隐藏的，在鼠标移动到元素显示. 设置了一些宽度、背景色、字体色等样式.</p>
<p>CSS3 <code>border-radius</code> 属性用于为提示框添加圆角.</p>
<p><code>:hover</code> 选择器用于在鼠标移动到到指定元素 <code>&lt;div&gt;</code> 上时显示的提示.</p>
<h4 id="定位提示工具"><a class="header" href="#定位提示工具">定位提示工具</a></h4>
<p>以下实例中，提示工具显示在指定元素的右侧(<code>left:105%</code>)</p>
<p>注意 <code>top:-5px</code> 同于定位在容器元素的中间. 使用数字 5 因为提示文本的顶部和底部的内边距（<code>padding</code>）是 5px. 如果你修改 <code>padding</code> 的值，<code>top</code> 值也要对应修改，这样才可以确保它是居中对齐的. 在提示框显示在左边的情况也是这个原理.</p>
<p><strong>显示在右侧</strong>：</p>
<pre><code class="language-css">.tooltip .tooltiptext {
    top: -5px;
    left: 105%;
}
</code></pre>
<p><strong>显示在左侧</strong>：</p>
<pre><code class="language-css">.tooltip .tooltiptext {
    top: -5px;
    right: 105%;
}
</code></pre>
<p>如果你想要提示工具显示在头部和底部, 我们需要使用 <code>margin-left</code> 属性，并设置为<code>-60px</code>. 这个数字计算来源是使用宽度的一半来居中对齐，即： <code>width/2 (120/2 = 60)</code>.</p>
<p><strong>显示在头部</strong>：</p>
<pre><code class="language-css">.tooltip .tooltiptext {
    width: 120px;
    bottom: 100%;
    left: 50%;
    margin-left: -60px; /* 使用一半宽度 (120/2 = 60) 来居中提示工具 */
}
</code></pre>
<p><strong>显示在底部</strong>：</p>
<pre><code class="language-css">.tooltip .tooltiptext {
    width: 120px;
    top: 100%;
    left: 50%;
    margin-left: -60px; /* 使用一半宽度 (120/2 = 60) 来居中提示工具 */
}
</code></pre>
<h4 id="添加箭头"><a class="header" href="#添加箭头">添加箭头</a></h4>
<p>我们可以用CSS 伪元素 <code>::after</code> 及 <code>content</code> 属性为提示工具创建一个小箭头标志，箭头是由边框组成的，但组合起来后提示工具像个语音信息框. 以下实例演示了如何为显示在顶部的提示工具添加底部箭头：</p>
<p><strong>顶部提示框/底部箭头</strong>：</p>
<pre><code class="language-css">.tooltip .tooltiptext::after {
    content: &quot; &quot;;
    position: absolute;
    top: 100%; /* 提示工具底部 */
    left: 50%;
    margin-left: -5px;
    border-width: 5px;
    border-style: solid;
    border-color: black transparent transparent transparent;
}
</code></pre>
<p>实例解析
在提示工具内定位箭头: <code>top: 100%</code> , 箭头将显示在提示工具的底部. <code>left: 50%</code> 用于居中对齐箭头.</p>
<p>注意：<code>border-width</code> 属性指定了箭头的大小. 如果你修改它，也要修改 <code>margin-left</code> 值. 这样箭头才能居中显示.</p>
<p><code>border-color</code> 用于将内容转换为箭头. 设置顶部边框为黑色，其他是透明的. 如果设置了其他的也是黑色则会显示为一个黑色的四边形.</p>
<p>以下实例演示了如何在提示工具的头部添加箭头，注意设置边框颜色：</p>
<p><strong>底部提示框/顶部箭头</strong>：</p>
<pre><code class="language-css">.tooltip .tooltiptext::after {
    content: &quot; &quot;;
    position: absolute;
    bottom: 100%;  /* 提示工具头部 */
    left: 50%;
    margin-left: -5px;
    border-width: 5px;
    border-style: solid;
    border-color: transparent transparent black transparent;
}
</code></pre>
<p>以下两个实例是左右两边的箭头实例：</p>
<p><strong>右侧提示框/左侧箭头</strong>：</p>
<pre><code class="language-css">.tooltip .tooltiptext::after {
    content: &quot; &quot;;
    position: absolute;
    top: 50%;
    right: 100%; /* 提示工具左侧 */
    margin-top: -5px;
    border-width: 5px;
    border-style: solid;
    border-color: transparent black transparent transparent;
}
</code></pre>
<p><strong>左侧提示框/右侧箭头</strong>：</p>
<pre><code class="language-css">.tooltip .tooltiptext::after {
    content: &quot; &quot;;
    position: absolute;
    top: 50%;
    left: 100%; /* 提示工具右侧 */
    margin-top: -5px;
    border-width: 5px;
    border-style: solid;
    border-color: transparent transparent transparent black;
}
</code></pre>
<h4 id="淡入效果"><a class="header" href="#淡入效果">淡入效果</a></h4>
<p>我们可以使用 CSS3 <code>transition</code> 属性及 <code>opacity</code> 属性来实现提示工具的淡入效果:</p>
<p><strong>淡入效果</strong>：</p>
<pre><code class="language-css">.tooltip .tooltiptext {
    opacity: 0;
    transition: opacity 1s;
}

.tooltip:hover .tooltiptext {
    opacity: 1;
}
</code></pre>
<h3 id="css-图片廊"><a class="header" href="#css-图片廊">CSS 图片廊</a></h3>
<p>以下是使用 CSS 创建图片廊：</p>
<pre><code class="language-html">&lt;div class=&quot;responsive&quot;&gt;
  &lt;div class=&quot;img&quot;&gt;
    &lt;a target=&quot;_blank&quot; href=&quot;http://static.runoob.com/images/demo/demo1.jpg&quot;&gt;
      &lt;img decoding=&quot;async&quot; src=&quot;http://static.runoob.com/images/demo/demo1.jpg&quot; alt=&quot;图片文本描述&quot; width=&quot;300&quot; height=&quot;200&quot;&gt;
    &lt;/a&gt;
    &lt;div class=&quot;desc&quot;&gt;这里添加图片文本描述&lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;

&lt;div class=&quot;responsive&quot;&gt;
  &lt;div class=&quot;img&quot;&gt;
    &lt;a target=&quot;_blank&quot; href=&quot;http://static.runoob.com/images/demo/demo2.jpg&quot;&gt;
      &lt;img decoding=&quot;async&quot; loading=&quot;lazy&quot; src=&quot;http://static.runoob.com/images/demo/demo2.jpg&quot; alt=&quot;图片文本描述&quot; width=&quot;300&quot; height=&quot;200&quot;&gt;
    &lt;/a&gt;
    &lt;div class=&quot;desc&quot;&gt;这里添加图片文本描述&lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;

&lt;div class=&quot;responsive&quot;&gt;
  &lt;div class=&quot;img&quot;&gt;
    &lt;a target=&quot;_blank&quot; href=&quot;http://static.runoob.com/images/demo/demo3.jpg&quot;&gt;
      &lt;img decoding=&quot;async&quot; loading=&quot;lazy&quot; src=&quot;http://static.runoob.com/images/demo/demo3.jpg&quot; alt=&quot;图片文本描述&quot; width=&quot;300&quot; height=&quot;200&quot;&gt;
    &lt;/a&gt;
    &lt;div class=&quot;desc&quot;&gt;这里添加图片文本描述&lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;

&lt;div class=&quot;responsive&quot;&gt;
  &lt;div class=&quot;img&quot;&gt;
    &lt;a target=&quot;_blank&quot; href=&quot;http://static.runoob.com/images/demo/demo4.jpg&quot;&gt;
      &lt;img decoding=&quot;async&quot; loading=&quot;lazy&quot; src=&quot;http://static.runoob.com/images/demo/demo4.jpg&quot; alt=&quot;图片文本描述&quot; width=&quot;300&quot; height=&quot;200&quot;&gt;
    &lt;/a&gt;
    &lt;div class=&quot;desc&quot;&gt;这里添加图片文本描述&lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>使用 CSS3 的媒体查询来创建响应式图片廊：</p>
<pre><code class="language-html">&lt;div class=&quot;responsive&quot;&gt;
  &lt;div class=&quot;img&quot;&gt;
    &lt;a target=&quot;_blank&quot; href=&quot;img_fjords.jpg&quot;&gt;
      &lt;img decoding=&quot;async&quot; loading=&quot;lazy&quot; src=&quot;http://www.runoob.com/wp-content/uploads/2016/04/img_fjords.jpg&quot; alt=&quot;Trolltunga Norway&quot; width=&quot;300&quot; height=&quot;200&quot;&gt;
    &lt;/a&gt;
    &lt;div class=&quot;desc&quot;&gt;这里添加图片文本描述&lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;


&lt;div class=&quot;responsive&quot;&gt;
  &lt;div class=&quot;img&quot;&gt;
    &lt;a target=&quot;_blank&quot; href=&quot;img_forest.jpg&quot;&gt;
      &lt;img decoding=&quot;async&quot; loading=&quot;lazy&quot; src=&quot;http://www.runoob.com/wp-content/uploads/2016/04/img_forest.jpg&quot; alt=&quot;Forest&quot; width=&quot;600&quot; height=&quot;400&quot;&gt;
    &lt;/a&gt;
    &lt;div class=&quot;desc&quot;&gt;这里添加图片文本描述&lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;

&lt;div class=&quot;responsive&quot;&gt;
  &lt;div class=&quot;img&quot;&gt;
    &lt;a target=&quot;_blank&quot; href=&quot;img_lights.jpg&quot;&gt;
      &lt;img decoding=&quot;async&quot; loading=&quot;lazy&quot; src=&quot;http://www.runoob.com/wp-content/uploads/2016/04/img_lights.jpg&quot; alt=&quot;Northern Lights&quot; width=&quot;600&quot; height=&quot;400&quot;&gt;
    &lt;/a&gt;
    &lt;div class=&quot;desc&quot;&gt;这里添加图片文本描述&lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;

&lt;div class=&quot;responsive&quot;&gt;
  &lt;div class=&quot;img&quot;&gt;
    &lt;a target=&quot;_blank&quot; href=&quot;img_mountains.jpg&quot;&gt;
      &lt;img decoding=&quot;async&quot; loading=&quot;lazy&quot; src=&quot;http://www.runoob.com/wp-content/uploads/2016/04/img_mountains.jpg&quot; alt=&quot;Mountains&quot; width=&quot;600&quot; height=&quot;400&quot;&gt;
    &lt;/a&gt;
    &lt;div class=&quot;desc&quot;&gt;这里添加图片文本描述&lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;

&lt;div class=&quot;clearfix&quot;&gt;&lt;/div&gt;

&lt;div style=&quot;padding:6px;&quot;&gt;

  &lt;h4&gt;重置浏览器大小查看效果&lt;/h4&gt;
&lt;/div&gt;
</code></pre>
<h3 id="css-图像透明不透明"><a class="header" href="#css-图像透明不透明">CSS 图像透明/不透明</a></h3>
<p>注意：CSS <code>Opacity</code>属性是W3C的CSS3建议的一部分.</p>
<p><strong>实例1 - 创建一个透明图像</strong></p>
<p>首先，展示如何用CSS创建一个透明图像.</p>
<pre><code class="language-css">img
{
  opacity:0.4;
  filter:alpha(opacity=40); /* IE8 及其更早版本 */
}
</code></pre>
<p><strong>实例2 - 图像的透明度 - 悬停效果</strong></p>
<pre><code class="language-css">img
{
  opacity:0.4;
  filter:alpha(opacity=40); /*  IE8 及其更早版本 */
}
img:hover
{
  opacity:1.0;
  filter:alpha(opacity=100); /* IE8 及其更早版本 */
}
</code></pre>
<p>第一个CSS块是和例1中的代码类似. 此外，我们还增加了当用户将鼠标悬停在其中一个图像上时发生什么. 在这种情况下，当用户将鼠标悬停在图像上时，我们希望图片是清晰的.</p>
<p>此CSS是：<code>opacity=1</code>.</p>
<p>当鼠标指针远离图像时，图像将重新具有透明度.</p>
<p><strong>实例3 - 透明的盒子中的文字</strong></p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;style&gt;
div.background
{
  width:500px;
  height:250px;
  background:url(https://www.runoob.com/images/klematis.jpg) repeat;
  border:2px solid black;
}
div.transbox
{
  width:400px;
  height:180px;
  margin:30px 50px;
  background-color:#ffffff;
  border:1px solid black;
  opacity:0.6;
  filter:alpha(opacity=60); /* IE8 及更早版本 */
}
div.transbox p
{
  margin:30px 40px;
  font-weight:bold;
  color:#000000;
}
&lt;/style&gt;
&lt;/head&gt;

&lt;body&gt;

&lt;div class=&quot;background&quot;&gt;
&lt;div class=&quot;transbox&quot;&gt;
&lt;p&gt;这些文本在透明框里。这些文本在透明框里。这些文本在透明框里。这些文本在透明框里。这些文本在透明框里。这些文本在透明框里。这些文本在透明框里。这些文本在透明框里。这些文本在透明框里。这些文本在透明框里。这些文本在透明框里。这些文本在透明框里。这些文本在透明框里。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>首先，我们创建一个固定的高度和宽度的<code>div</code>元素，带有一个背景图片和边框. 然后我们在第一个<code>div</code>内部创建一个较小的<code>div</code>元素. 这个<code>div</code>也有一个固定的宽度，背景颜色，边框 - 而且它是透明的. 透明的div里面，我们在<code>P</code>元素内部添加一些文本.</p>
<h3 id="css-图像拼合技术"><a class="header" href="#css-图像拼合技术">CSS 图像拼合技术</a></h3>
<h4 id="图像拼合"><a class="header" href="#图像拼合">图像拼合</a></h4>
<p>图像拼合就是单个图像的集合. 有许多图像的网页可能需要很长的时间来加载和生成多个服务器的请求. 使用图像拼合会降低服务器的请求数量，并节省带宽.</p>
<h4 id="图像拼合---简单实例"><a class="header" href="#图像拼合---简单实例">图像拼合 - 简单实例</a></h4>
<p>有了CSS，我们可以只显示我们需要的图像的一部分. 在下面的例子CSS指定显示 &quot;img_navsprites.gif&quot; 的图像的一部分：</p>
<pre><code class="language-css">img.home
{
width:46px;
height:44px;
background:url(img_navsprites.gif) 0 0;
}
</code></pre>
<p>实例解析：</p>
<ul>
<li><code>&lt;img class=&quot;home&quot; src=&quot;img_trans.gif&quot; /&gt;</code> -因为不能为空, <code>src</code>属性只定义了一个小的透明图像. 显示的图像将是我们在CSS中指定的背景图像</li>
<li>宽度：<code>46px</code>;高度：<code>44px</code>; - 定义我们使用的那部分图像</li>
<li><code>background:url(img_navsprites.gif) 0 0;</code> - 定义背景图像和它的位置（左<code>0px</code>，顶部<code>0px</code>）</li>
</ul>
<p>这是使用图像拼合最简单的方法，现在我们使用链接和悬停效果.</p>
<h4 id="图像拼合---创建一个导航列表"><a class="header" href="#图像拼合---创建一个导航列表">图像拼合 - 创建一个导航列表</a></h4>
<p>我们想使用拼合图像 (&quot;img_navsprites.gif&quot;)，以创建一个导航列表. 我们将使用一个HTML列表，因为它可以链接，同时还支持背景图像：</p>
<pre><code class="language-css">#navlist{position:relative;}
#navlist li{margin:0;padding:0;list-style:none;position:absolute;top:0;}
#navlist li, #navlist a{height:44px;display:block;}

#home{left:0px;width:46px;}
#home{background:url('img_navsprites.gif') 0 0;}

#prev{left:63px;width:43px;}
#prev{background:url('img_navsprites.gif') -47px 0;}

#next{left:129px;width:43px;}
#next{background:url('img_navsprites.gif') -91px 0;}
</code></pre>
<p>实例解析：</p>
<ul>
<li><code>#navlist{position:relative;}</code> - 位置设置相对定位，让里面的绝对定位</li>
<li><code>#navlist li{margin:0;padding:0;list-style:none;position:absolute;top:0;}</code> - <code>margin</code>和<code>padding</code>设置为0，列表样式被删除，所有列表项是绝对定位</li>
<li><code>#navlist li, #navlist a{height:44px;display:block;}</code> - 所有图像的高度是<code>44px</code></li>
</ul>
<p>现在开始每个具体部分的定位和样式：</p>
<ul>
<li><code>#home{left:0px;width:46px;}</code> - 定位到最左边的方式，以及图像的宽度是<code>46px</code></li>
<li><code>#home{background:url(img_navsprites.gif) 0 0;}</code> - 定义背景图像和它的位置（左<code>0px</code>，顶部<code>0px</code>）</li>
<li><code>#prev{left:63px;width:43px;}</code> - 右侧定位<code>63px</code>（<code>＃home</code>宽<code>46px</code>+项目之间的一些多余的空间），宽度为<code>43px</code></li>
<li><code>#prev{background:url('img_navsprites.gif') -47px 0;}</code> - 定义背景图像右侧<code>47px</code>（<code>＃home</code>宽<code>46px</code>+分隔线的<code>1px</code>）</li>
<li><code>#next{left:129px;width:43px;}</code>- 右边定位<code>129px</code>(<code>#prev</code> <code>63px</code> + <code>#prev</code>宽是<code>43px</code> + 剩余的空间), 宽度是<code>43px</code>.</li>
<li><code>#next{background:url('img_navsprites.gif') no-repeat -91px 0;}</code> - 定义背景图像右边<code>91px</code>（<code>＃home</code> <code>46px</code>+<code>1px</code>的分割线+<code>＃prev</code>宽<code>43px</code>+<code>1px</code>的分隔线）</li>
</ul>
<h4 id="图像拼合---悬停效果"><a class="header" href="#图像拼合---悬停效果">图像拼合 - 悬停效果</a></h4>
<p>现在，我们希望我们的导航列表中添加一个悬停效果. <code>:hover</code> 选择器用于鼠标悬停在元素上的显示的效果. <code>:hover</code> 选择器可以运用于所有元素. 我们的新图像 (&quot;img_navsprites_hover.gif&quot;) 包含三个导航图像和三幅图像, 因为这是一个单一的图像，而不是6个单独的图像文件，当用户停留在图像上不会有延迟加载.</p>
<p>我们添加悬停效果只添加三行代码：</p>
<pre><code class="language-css">#home a:hover{background: url('img_navsprites_hover.gif') 0 -45px;}
#prev a:hover{background: url('img_navsprites_hover.gif') -47px -45px;}
#next a:hover{background: url('img_navsprites_hover.gif') -91px -45px;}
</code></pre>
<p>实例解析：</p>
<ul>
<li>由于该列表项包含一个链接，我们可以使用<code>：hover</code>伪类</li>
<li><code>#home a:hover{background: transparent url(img_navsprites_hover.gif) 0 -45px;}</code> - 对于所有三个悬停图像，我们指定相同的背景位置，只是每个再向下<code>45px</code></li>
</ul>
<h3 id="css-属性-选择器"><a class="header" href="#css-属性-选择器">CSS 属性 选择器</a></h3>
<p>具有特定属性的HTML元素样式不仅仅是class和id.</p>
<h4 id="属性选择器"><a class="header" href="#属性选择器">属性选择器</a></h4>
<p>下面的例子是把包含标题（<code>title</code>）的所有元素变为蓝色：</p>
<pre><code class="language-css">[title]
{
    color:blue;
}
</code></pre>
<h4 id="属性和值选择器"><a class="header" href="#属性和值选择器">属性和值选择器</a></h4>
<p>下面的实例改变了标题<code>title='runoob'</code>元素的边框样式:</p>
<pre><code class="language-css">[title=runoob]
{
    border:5px solid green;
}
</code></pre>
<h4 id="属性和值的选择器---多值"><a class="header" href="#属性和值的选择器---多值">属性和值的选择器 - 多值</a></h4>
<p>下面是包含指定值的<code>title</code>属性的元素样式的例子，使用<code>~</code>分隔属性和值:</p>
<pre><code class="language-css">[title~=hello] { color:blue; }
</code></pre>
<p>下面是包含指定值的<code>lang</code>属性的元素样式的例子，使用<code>|</code>分隔属性和值:</p>
<pre><code class="language-css">[lang|=en] { color:blue; }
</code></pre>
<h4 id="表单样式"><a class="header" href="#表单样式">表单样式</a></h4>
<p>属性选择器样式无需使用<code>class</code>或<code>id</code>的形式:</p>
<pre><code class="language-css">input[type=&quot;text&quot;]
{
    width:150px;
    display:block;
    margin-bottom:10px;
    background-color:yellow;
}
input[type=&quot;button&quot;]
{
    width:120px;
    margin-left:35px;
    display:block;
}
</code></pre>
<h3 id="css-表单"><a class="header" href="#css-表单">CSS 表单</a></h3>
<p>一个表单案例，我们使用 CSS 来渲染 HTML 的表单元素：</p>
<pre><code class="language-css">input[type=text], select {
  width: 100%;
  padding: 12px 20px;
  margin: 8px 0;
  display: inline-block;
  border: 1px solid #ccc;
  border-radius: 4px;
  box-sizing: border-box;
}

input[type=submit] {
  width: 100%;
  background-color: #4CAF50;
  color: white;
  padding: 14px 20px;
  margin: 8px 0;
  border: none;
  border-radius: 4px;
  cursor: pointer;
}

input[type=submit]:hover {
  background-color: #45a049;
}

div {
  border-radius: 5px;
  background-color: #f2f2f2;
  padding: 20px;
}
</code></pre>
<h4 id="输入框input-样式"><a class="header" href="#输入框input-样式">输入框(input) 样式</a></h4>
<p>使用 <code>width</code> 属性来设置输入框的宽度：</p>
<pre><code class="language-css">input {
  width: 100%;
}
</code></pre>
<p>以上实例中设置了所有 <code>&lt;input&gt;</code> 元素的宽度为 <code>100%</code>，如果你只想设置指定类型的输入框可以使用以下属性选择器：</p>
<ul>
<li><code>input[type=text]</code> - 选取文本输入框</li>
<li><code>input[type=password]</code> - 选择密码的输入框</li>
<li><code>input[type=number]</code> - 选择数字的输入框</li>
<li>...</li>
</ul>
<h4 id="输入框填充"><a class="header" href="#输入框填充">输入框填充</a></h4>
<p>使用 <code>padding</code> 属性可以在输入框中添加内边距.</p>
<pre><code class="language-css">input[type=text] {
  width: 100%;
  padding: 12px 20px;
  margin: 8px 0;
  box-sizing: border-box;
}
</code></pre>
<p>注意我们设置了 <code>box-sizing</code> 属性为 <code>border-box</code>. 这样可以确保浏览器呈现出带有指定宽度和高度的输入框是把边框和内边距一起计算进去的.</p>
<h4 id="输入框input-边框"><a class="header" href="#输入框input-边框">输入框(input) 边框</a></h4>
<p>使用 <code>border</code> 属性可以修改 <code>input</code> 边框的大小或颜色，使用 <code>border-radius</code> 属性可以给 <code>input</code> 添加圆角：</p>
<pre><code class="language-css">input[type=text] {
  border: 2px solid red;
  border-radius: 4px;
}
</code></pre>
<p>如果你只想添加底部边框可以使用 <code>border-bottom</code> 属性:</p>
<pre><code class="language-css">input[type=text] {
  border: none;
  border-bottom: 2px solid red;
}
</code></pre>
<h4 id="输入框input-颜色"><a class="header" href="#输入框input-颜色">输入框(input) 颜色</a></h4>
<p>可以使用 <code>background-color</code> 属性来设置输入框的背景颜色，<code>color</code> 属性用于修改文本颜色：</p>
<pre><code class="language-css">input[type=text] {
  background-color: #3CBC8D;
  color: white;
}
</code></pre>
<h4 id="输入框input-聚焦"><a class="header" href="#输入框input-聚焦">输入框(input) 聚焦</a></h4>
<p>默认情况下，一些浏览器在输入框获取焦点时（点击输入框）会有一个蓝色轮廓. 我们可以设置 <code>input</code> 样式为 <code>outline: none;</code> 来忽略该效果.</p>
<p>使用 <code>:focus</code> 选择器可以设置输入框在获取焦点时的样式：</p>
<pre><code class="language-css">input[type=text]:focus {
  background-color: lightblue;
}
</code></pre>
<pre><code class="language-css">input[type=text]:focus {
  border: 3px solid #555;
}
</code></pre>
<h4 id="输入框input-图标"><a class="header" href="#输入框input-图标">输入框(input) 图标</a></h4>
<p>如果你想在输入框中添加图标，可以使用 <code>background-image</code> 属性和用于定位的<code>background-position</code> 属性. 注意设置图标的左边距，让图标有一定的空间：</p>
<pre><code class="language-css">input[type=text] {
  background-color: white;
  background-image: url('searchicon.png');
  background-position: 10px 10px;
  background-repeat: no-repeat;
  padding-left: 40px;
}
</code></pre>
<h4 id="带动画的搜索框"><a class="header" href="#带动画的搜索框">带动画的搜索框</a></h4>
<p>以下实例使用了 CSS <code>transition</code> 属性，该属性设置了输入框在获取焦点时会向右延展.</p>
<pre><code class="language-css">input[type=text] {
  -webkit-transition: width 0.4s ease-in-out;
  transition: width 0.4s ease-in-out;
}

input[type=text]:focus {
  width: 100%;
}
</code></pre>
<h4 id="文本框textarea样式"><a class="header" href="#文本框textarea样式">文本框（textarea）样式</a></h4>
<p>注意: 使用 <code>resize</code> 属性来禁用文本框可以重置大小的功能（一般拖动右下角可以重置大小）</p>
<pre><code class="language-css">textarea {
  width: 100%;
  height: 150px;
  padding: 12px 20px;
  box-sizing: border-box;
  border: 2px solid #ccc;
  border-radius: 4px;
  background-color: #f8f8f8;
  resize: none;
}
</code></pre>
<h4 id="下拉菜单select样式"><a class="header" href="#下拉菜单select样式">下拉菜单（select）样式</a></h4>
<pre><code class="language-css">select {
  width: 100%;
  padding: 16px 20px;
  border: none;
  border-radius: 4px;
  background-color: #f1f1f1;
}
</code></pre>
<h4 id="按钮样式"><a class="header" href="#按钮样式">按钮样式</a></h4>
<pre><code class="language-css">input[type=button], input[type=submit], input[type=reset] {
  background-color: #4CAF50;
  border: none;
  color: white;
  padding: 16px 32px;
  text-decoration: none;
  margin: 4px 2px;
  cursor: pointer;
}

/* 提示: 使用 width: 100% 设置全宽按钮 */
</code></pre>
<h4 id="响应式表单"><a class="header" href="#响应式表单">响应式表单</a></h4>
<p>响应式表单可以根据浏览器窗口的大小重新布局各个元素，我们可以通过重置浏览器窗口大小来查看效果：</p>
<pre><code class="language-css">* {
  box-sizing: border-box;
}

input[type=text], select, textarea {
  width: 100%;
  padding: 12px;
  border: 1px solid #ccc;
  border-radius: 4px;
  resize: vertical;
}

label {
  padding: 12px 12px 12px 0;
  display: inline-block;
}

input[type=submit] {
  background-color: #4CAF50;
  color: white;
  padding: 12px 20px;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  float: right;
}

input[type=submit]:hover {
  background-color: #45a049;
}

.container {
  border-radius: 5px;
  background-color: #f2f2f2;
  padding: 20px;
}

.col-25 {
  float: left;
  width: 25%;
  margin-top: 6px;
}

.col-75 {
  float: left;
  width: 75%;
  margin-top: 6px;
}

/* 清除浮动 */
.row:after {
  content: &quot;&quot;;
  display: table;
  clear: both;
}

/* 响应式布局 layout - 在屏幕宽度小于 600px 时， 设置为上下堆叠元素 */
@media screen and (max-width: 600px) {
  .col-25, .col-75, input[type=submit] {
    width: 100%;
    margin-top: 0;
  }
}
</code></pre>
<h3 id="css-计数器"><a class="header" href="#css-计数器">CSS 计数器</a></h3>
<p>CSS 计数器通过一个变量来设置，根据规则递增变量.</p>
<h4 id="使用计数器自动编号"><a class="header" href="#使用计数器自动编号">使用计数器自动编号</a></h4>
<p>CSS 计数器根据规则来递增变量. CSS 计数器使用到以下几个属性：</p>
<ul>
<li><code>counter-reset</code> - 创建或者重置计数器</li>
<li><code>counter-increment</code> - 递增变量</li>
<li><code>content</code> - 插入生成的内容</li>
<li><code>counter()</code> 或 <code>counters()</code> 函数 - 将计数器的值添加到元素</li>
</ul>
<p>要使用 CSS 计数器，得先用 <code>counter-reset</code> 创建：</p>
<p>以下实例在页面创建一个计数器 (在 body 选择器中)，每个 <code>&lt;h2&gt;</code> 元素的计数值都会递增，并在每个 <code>&lt;h2&gt;</code> 元素前添加 <code>&quot;Section &lt;计数值&gt;:&quot;</code></p>
<pre><code class="language-css">body {
  counter-reset: section;
}

h2::before {
  counter-increment: section;
  content: &quot;Section &quot; counter(section) &quot;: &quot;;
}
</code></pre>
<h4 id="嵌套计数器"><a class="header" href="#嵌套计数器">嵌套计数器</a></h4>
<p>以下实例在页面创建一个计数器，在每一个 <code>&lt;h1&gt;</code> 元素前添加计数值 <code>&quot;Section &lt;主标题计数值&gt;.&quot;</code>, 嵌套的计数值则放在 <code>&lt;h2&gt;</code> 元素的前面，内容为 <code>&quot;&lt;主标题计数值&gt;.&lt;副标题计数值&gt;&quot;</code>:</p>
<pre><code class="language-css">body {
  counter-reset: section;
}

h1 {
  counter-reset: subsection;
}

h1::before {
  counter-increment: section;
  content: &quot;Section &quot; counter(section) &quot;. &quot;;
}

h2::before {
  counter-increment: subsection;
  content: counter(section) &quot;.&quot; counter(subsection) &quot; &quot;;
}
</code></pre>
<p>计数器也可用于列表中，列表的子元素会自动创建. 这里我们使用了 <code>counters()</code> 函数在不同的嵌套层级中插入字符串:</p>
<pre><code class="language-css">ol {
  counter-reset: section;
  list-style-type: none;
}

li::before {
  counter-increment: section;
  content: counters(section,&quot;.&quot;) &quot; &quot;;

}
</code></pre>
<h4 id="css-计数器属性"><a class="header" href="#css-计数器属性">CSS 计数器属性</a></h4>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">属性</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: left">content</td><td style="text-align: left">使用 <code>::before</code> 和 <code>::after</code> 伪元素来插入自动生成的内容</td></tr>
<tr><td style="text-align: left">counter-increment</td><td style="text-align: left">递增一个或多个值</td></tr>
<tr><td style="text-align: left">counter-reset</td><td style="text-align: left">创建或重置一个或多个计数器</td></tr>
</tbody></table>
</div>
<h3 id="css-网页布局"><a class="header" href="#css-网页布局">CSS 网页布局</a></h3>
<h4 id="头部区域"><a class="header" href="#头部区域">头部区域</a></h4>
<p>头部区域位于整个网页的顶部，一般用于设置网页的标题或者网页的 logo：</p>
<pre><code class="language-css">.header {
  background-color: #F1F1F1;
  text-align: center;
  padding: 20px;
}
</code></pre>
<h4 id="菜单导航区域"><a class="header" href="#菜单导航区域">菜单导航区域</a></h4>
<p>菜单导航条包含了一些链接，可以引导用户浏览其他页面：</p>
<pre><code class="language-css">/* 导航条 */
.topnav {
  overflow: hidden;
  background-color: #333;
}

/* 导航链接 */
.topnav a {
  float: left;
  display: block;
  color: #f2f2f2;
  text-align: center;
  padding: 14px 16px;
  text-decoration: none;
}

/* 链接 - 修改颜色 */
.topnav a:hover {
  background-color: #ddd;
  color: black;
}
</code></pre>
<h4 id="内容区域"><a class="header" href="#内容区域">内容区域</a></h4>
<p>内容区域一般有三种形式:</p>
<ul>
<li>1 列：一般用于移动端</li>
<li>2 列：一般用于平板设备</li>
<li>3 列：一般用于 PC 桌面设备</li>
</ul>
<p>我们将创建一个 3 列布局，在小的屏幕上将会变成 1 列布局（响应式）：</p>
<pre><code class="language-css">/* 创建三个相等的列 */
.column {
  float: left;
  width: 33.33%;
}

/* 列后清除浮动 */
.row:after {
  content: &quot;&quot;;
  display: table;
  clear: both;
}

/* 响应式布局 - 小于 600 px 时改为上下布局 */
@media screen and (max-width: 600px) {
  .column {
    width: 100%;
  }
}
</code></pre>
<p>提示:要设置两列可以设置 <code>width</code> 为 <code>50%</code>. 创建 4 列可以设置为 <code>25%</code>
提示: 现在更高级的方式是使用 CSS Flexbox 来创建列的布局，但 Internet Explorer 10 及更早的版本不支持该方式， IE6-10 可以使用浮动方式</p>
<h4 id="不相等的列"><a class="header" href="#不相等的列">不相等的列</a></h4>
<p>不相等的列一般是在中间部分设置内容区域，这块也是最大最主要的，左右两次侧可以作为一些导航等相关内容，这三列加起来的宽度是 100％.</p>
<pre><code class="language-css">.column {
  float: left;
}

/* 左右侧栏的宽度 */
.column.side {
  width: 25%;
}

/* 中间列宽度 */
.column.middle {
  width: 50%;
}

/* 响应式布局 - 宽度小于600px时设置上下布局 */
@media screen and (max-width: 600px) {
  .column.side, .column.middle {
    width: 100%;
  }
}
</code></pre>
<h4 id="底部区域"><a class="header" href="#底部区域">底部区域</a></h4>
<p>底部区域在网页的最下方，一般包含版权信息和联系方式等.</p>
<pre><code class="language-css">.footer {
  background-color: #F1F1F1;
  text-align: center;
  padding: 10px;
}
</code></pre>
<h4 id="响应式网页布局"><a class="header" href="#响应式网页布局">响应式网页布局</a></h4>
<p>通过以上等学习我们来创建一个响应式等页面，页面的布局会根据屏幕的大小来调整：</p>
<pre><code class="language-css">* {
  box-sizing: border-box;
}

body {
  font-family: Arial;
  padding: 10px;
  background: #f1f1f1;
}

/* 头部标题 */
.header {
  padding: 30px;
  text-align: center;
  background: white;
}

.header h1 {
  font-size: 50px;
}

/* 导航条 */
.topnav {
  overflow: hidden;
  background-color: #333;
}

/* 导航条链接 */
.topnav a {
  float: left;
  display: block;
  color: #f2f2f2;
  text-align: center;
  padding: 14px 16px;
  text-decoration: none;
}

/* 链接颜色修改 */
.topnav a:hover {
  background-color: #ddd;
  color: black;
}

/* 创建两列 */
/* Left column */
.leftcolumn {
  float: left;
  width: 75%;
}

/* 右侧栏 */
.rightcolumn {
  float: left;
  width: 25%;
  background-color: #f1f1f1;
  padding-left: 20px;
}

/* 图像部分 */
.fakeimg {
  background-color: #aaa;
  width: 100%;
  padding: 20px;
}

/* 文章卡片效果 */
.card {
  background-color: white;
  padding: 20px;
  margin-top: 20px;
}

/* 列后面清除浮动 */
.row:after {
  content: &quot;&quot;;
  display: table;
  clear: both;
}

/* 底部 */
.footer {
  padding: 20px;
  text-align: center;
  background: #ddd;
  margin-top: 20px;
}

/* 响应式布局 - 屏幕尺寸小于 800px 时，两列布局改为上下布局 */
@media screen and (max-width: 800px) {
  .leftcolumn, .rightcolumn {
    width: 100%;
    padding: 0;
  }
}

/* 响应式布局 -屏幕尺寸小于 400px 时，导航等布局改为上下布局 */
@media screen and (max-width: 400px) {
  .topnav a {
    float: none;
    width: 100%;
  }
}
</code></pre>
<h3 id="css-important-规则"><a class="header" href="#css-important-规则">CSS !important 规则</a></h3>
<h4 id="什么是-important"><a class="header" href="#什么是-important">什么是 !important</a></h4>
<p>CSS 中的 <code>!important</code> 规则用于增加样式的权重. <code>!important</code> 与优先级无关，但它与最终的结果直接相关，使用一个 <code>!important</code> 规则时，此声明将覆盖任何其他声明.</p>
<pre><code class="language-css">#myid {
  background-color: blue;
}

.myclass {
  background-color: gray;
}

p {
  background-color: red !important;
}
</code></pre>
<p>以上实例中，尽管 ID 选择器和类选择器具有更高的优先级，但三个段落背景颜色都显示为红色，因为 <code>!important</code> 规则会覆盖 <code>background-color</code> 属性.</p>
<h4 id="重要说明"><a class="header" href="#重要说明">重要说明</a></h4>
<p>使用 <code>!important</code> 是一个坏习惯，应该尽量避免，因为这破坏了样式表中的固有的级联规则 使得调试找 bug 变得更加困难了. 当两条相互冲突的带有 <code>!important</code> 规则的声明被应用到相同的元素上时，拥有更大优先级的声明将会被采用.</p>
<p>以下实例我们在查看 CSS 源码时就不是很清楚哪种颜色最重要：</p>
<pre><code class="language-css">#myid {
  background-color: blue !important;
}

.myclass {
  background-color: gray !important;
}

p {
  background-color: red !important;
}
</code></pre>
<p>使用建议：</p>
<ul>
<li><strong>一定</strong>要优先考虑使用样式规则的优先级来解决问题而不是 <code>!important</code></li>
<li><strong>只有</strong>在需要覆盖全站或外部 CSS 的特定页面中使用 <code>!important</code></li>
<li><strong>永远</strong>不要在你的插件中使用 <code>!important</code></li>
<li><strong>永远</strong>不要在全站范围的 CSS 代码中使用 <code>!important</code></li>
</ul>
<h4 id="何时使用-important"><a class="header" href="#何时使用-important">何时使用 <code>!important</code></a></h4>
<p>如果要在你的网站上设定一个全站样式的 CSS 样式可以使用 <code>!important</code>.
比如我们要让网站上所有按钮的样式都一样：</p>
<pre><code class="language-css">.button {
  background-color: #8c8c8c;
  color: white;
  padding: 5px;
  border: 1px solid black;
}
</code></pre>
<p>如果我们将按钮放在另一个具有更优先级的元素中，按钮的外观就会发生变化，并且属性会发生冲突，如下实例：</p>
<pre><code class="language-css">.button {
  background-color: #8c8c8c;
  color: white;
  padding: 5px;
  border: 1px solid black;
}

#myDiv a {
  color: red;
  background-color: yellow;
}
</code></pre>
<p>如果想要设置所有按钮具有相同的外观，我们可以将 <code>!important</code> 规则添加到按钮的样式属性中，如下所示：</p>
<pre><code class="language-css">.button {
  background-color: #8c8c8c !important;
  color: white !important;
  padding: 5px !important;
  border: 1px solid black !important;
}

#myDiv a {
  color: red;
  background-color: yellow;
}
</code></pre>

                    <div id="giscus-container"></div>
                </main>

                <nav class="nav-wrapper" aria-label="Page navigation">
                    <!-- Mobile navigation buttons -->
                    <a rel="prev" href="../../python/crawler/pre.html" class="mobile-nav-chapters previous"
                        title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../../python/crawler/BeautifulSoup.html" class="mobile-nav-chapters next"
                        title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>

                    <div style="clear: both"></div>
                </nav>
            </div>
        </div>

        <nav class="nav-wide-wrapper" aria-label="Page navigation">
            <a rel="prev" href="../../python/crawler/pre.html" class="nav-chapters previous" title="Previous chapter"
                aria-label="Previous chapter" aria-keyshortcuts="Left">
                <i class="fa fa-angle-left"></i>
            </a>

            <a rel="next" href="../../python/crawler/BeautifulSoup.html" class="nav-chapters next" title="Next chapter"
                aria-label="Next chapter" aria-keyshortcuts="Right">
                <i class="fa fa-angle-right"></i>
            </a>
        </nav>

    </div>




    <script type="text/javascript">
        window.playground_copyable = true;
    </script>

    <script src="../../ace.js" type="text/javascript" charset="utf-8"></script>
    <script src="../../editor.js" type="text/javascript" charset="utf-8"></script>
    <script src="../../mode-rust.js" type="text/javascript" charset="utf-8"></script>
    <script src="../../theme-dawn.js" type="text/javascript" charset="utf-8"></script>
    <script src="../../theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>

    <script src="../../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="../../mark.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="../../searcher.js" type="text/javascript" charset="utf-8"></script>

    <script src="../../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="../../highlight.js" type="text/javascript" charset="utf-8"></script>
    <script src="../../book.js" type="text/javascript" charset="utf-8"></script>
    <script type="text/javascript" charset="utf-8">
        var pagePath = "python/crawler/html.md"
    </script>


    <!-- Custom JS scripts -->
    <script type="text/javascript" src="../../assets/custom.js"></script>
    <script type="text/javascript" src="../../assets/bigPicture.js"></script>


</body>

</html>